-- =======================================================================
--[[    Interaction Dot Marks ("DotMarks")
-- ===================================================================--]]
script_name     = "ui_hud_dotmarks"
--[[======================================================================
	Author: Catspaw (CatspawMods @ ModDB)
	Source: https://www.moddb.com/mods/stalker-anomaly/addons/interaction-dot-marks/

	I post gameplay video on my Youtube channel, Catspaw Adventures: 
	https://www.youtube.com/@CatspawAdventures
-- =======================================================================
	A blatant imitation of the "interaction dot" HUD markers in Stalker 2,
	and some of its other UI niceties such as floating prompts and 
	secondary interactions.
-- =======================================================================
	KNOWN ISSUES / TO-DO
-- =======================================================================
	(**) Improve performance - optimize string ops, texture inits, loops
		This will be a long-term, ongoing effort
		investigate string overhead (if any) from disabled logging
	(**) Hold indicator doesn't scale with UI/button scaling
		cosmetic, but alignment of these elements needs review anyway
	(*) Task target focus marker doesn't go away when task ends
		only happens when you end task in dialogue, low pri
	(*) Vehicle prompt focus doesn't match 1:1 with vanilla prompt
		which is because vehicle hitboxes are fuckhuge
		look into detecting whether actor is looking at any vehicle bone

	Low priority:
	- Blank textures are white squares in DX8/DX9
		current workaround via scan_unmarked_classes config setting
		investigate setting alpha to 0 to hide, instead of blank textures
	- PAW-style live preview for prompt elements - lots of work
		Look into possibly using imgui
	- NPE module(s) - not hard, but time-consuming and low priority
		First create timed floating interstitial prompt, to ask user
		if they want to see the tutorial without interrupting gameplay
	- New feature: when unloaded, unload prompt changes to field strip
	- Review adding support for Placeable Explosives addon (PES)
		From what I understand they're implemented using the Hideout
		Furniture framework, which means they'll either be trivially 
		easy or a titanic pain in the ass
		Has some kind of interactive keypad that needs accounting for
-- ===================================================================--]]
--      DEPENDENCIES
-- =======================================================================
assert(dotmarks_main, "\n\n"..
	"! ui_hud_dotmarks requires script dotmarks_main, which does not exist or failed to load!\n\n"
)
assert(dotmarks_mcm, "\n\n"..
	"! ui_hud_dotmarks requires script dotmarks_mcm, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_common and utils_catspaw_common.import_metatable, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_common, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_hudmarks, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_hudmarks, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_text and utils_catspaw_text.bindtext, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_text, which is missing or outdated!\n" ..
	"Version found: " .. (utils_catspaw_text and utils_catspaw_text.script_version or "missing!") .. " | Required: 1.4+\n" ..
	"If the version is outdated, try moving this addon to the bottom of your load order."
)
assert(utils_catspaw_mapspots, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_mapspots, which does not exist or failed to load!\n\n"
)
utils_catspaw_common.import_metatable(this, dotmarks_main)
-- This script imports dotmarks_main into its metatable, effectively including its public namespace here. 
-- If a public key does not exist in ui_hud_dotmarks, search dotmarks_main (and its imports)
printf("Interaction Dot Marks %s (rel %s) began initialization at %s", script_version or "(version not found)", release_date or "missing", time_global())
-- =======================================================================
local dl, vl, pl, xml
logprefix   = "[DotMarks] "
debuglogs   = false
verbose     = false
debug_dump  = false

function allow_local_logging(onoff)
	-- By default, logging in this script inherits its debuglogs/verbose settings from utils_catspaw_common
	-- This function allows anyone to temporarily switch on debug logging for this script's operations only
	if onoff then
		dl = function(logtext, ...) dlog(this, logtext, ...) end
		vl = function(logtext, ...) vlog(this, logtext, ...) end
		pl = function(prefix, logtext, ...) plog(this, prefix, logtext, ...) end
	else
		dl = function(logtext, ...) dlog(nil, logtext, ...) end
		vl = function(logtext, ...) vlog(nil, logtext, ...) end
		pl = function(prefix, logtext, ...) plog(nil, prefix, logtext, ...) end
	end
end
allow_local_logging(true)

local function dump(logtext, ...)
	return debug_dump and logtext and printf(logprefix .. logtext, ...)
end

local function alert(logtext, ...)
	if not logtext then return end
	pl("! ", logtext, ...)
end

function set_debug_logging(debug_en, verbose_en, dump_en)
	if (debug_en ~= nil) then debuglogs = debug_en end
	if (verbose_en ~= nil) then verbose = verbose_en end
	if (dump_en ~= nil) then debug_dump = dump_en end
end

--set_debug_logging(true, true, true) --uncomment this line to enable all logging for troubleshooting
-- First two values will be overridden by MCM once the game loads
-- debug_dump is EXTREMELY noisy and should only ever be manually enabled for a specific, targeted reason

function tracelog(event, fname, val)
	if not cfg.debug_trace then return end
	local fn = fname or script_name
	--local ts = time_global()
	local ts = os.clock()
	local ev = event or "heartbeat"
	cfg.metrics = cfg.metrics or {}
	cfg.metrics[ts] = cfg.metrics[ts] or {}
	local i = #cfg.metrics[ts] + 1
	cfg.metrics[ts][i] = cfg.metrics[ts][i] or {}
	cfg.metrics[ts][i][fn] = cfg.metrics[ts][i][fn] or {}
	cfg.metrics[ts][i][fn][ev] = val or ""
	printf("%s [%s][%s] Trace: [%s][%s] %s", logprefix, ts, i, fn, ev, val or "")
end

function dump_debug_trace()
	if not cfg.debug_trace then return end
	printf(logprefix.."Dumping runtime metrics for %s", script_name)
	for t,m in pairs(cfg.metrics) do
		for i = 1,#m do
			local fns = m[i]
			for f,evs in pairs(fns) do
				for e,v in pairs(evs) do
					dump("[%s][%s] [%s][%s] %s", t, i, f, e, v or "")
				end
			end
		end
	end
end

-- ======================================================================
--      SHORTCUTS
-- ======================================================================
local get_mcm           = get_mcm_or_default_val
local nameid            = obj_name_and_id
local get_argb          = utils_catspaw_mapspots.get_argb
local is_already_target = utils_catspaw_hudmarks.is_object_already_targeted
local get_task_target   = utils_catspaw_taskmonitor and utils_catspaw_taskmonitor.get_active_target_id or function() end
local tuthooks          = modxml_tutorial_hooks
local is_favorite       = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_favorite
local is_junk           = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_junk
local fdda_pickup       = z_fdda_pickup_intercept_dotmarks
local fddar_bodysearch  = liz_fdda_redone_body_search
local gts               = game.translate_string
local psk       		= utils_data.parse_string_keys
local ini_parts 		= itms_manager.ini_parts
-- ======================================================================
valid_mcm_version       = dotmarks_mcm.valid_mcm_version
targeted_id, locked_id  = nil
scanning                = false
pickup_index            = {}
nearby_pickups          = {}
active_anims            = {}
-- ======================================================================
local st_kg             = gts("st_kg")
local fdda_installed    = false
local fddar_installed   = false
local anims_enabled     = false
local anim_playing      = false
local actor_moved       = false
local base_failed 		= nil
local maingameui        = nil
local hmm               = nil
local popin_active      = nil
local use_dik           = nil
local fdda_callback     = nil
local hintfilters       = nil
local fallback_font     = 2
local next_near_scan    = 0
local next_early_scan   = 0
local next_tut_check    = 0
local loop_num 			= 0

-- ======================================================================
--      HUD MARKER PRESET PATCH
--  Set up "dotmark" preset and patch it into utils_catspaw_hudmarks
-- ======================================================================
utils_catspaw_hudmarks.marker_presets["dotmark"] = (
	--- @param args table
	function(args)
		--[[    This defines all the "default" values for any marker instantiated as
				a "dotmark" preset by utils_catspaw_hudmarks      --]]
		local id    = args and args.id
		local preset_args = {
			-- ================================================================================
			--  Presets that need to be generated on-marker-create rather than static LTX defs
			-- ================================================================================
			id                  = id,
			far_fade_dist       = near_scan_radius() - 1,
			far_hide_dist       = 1,
			far_end_dist        = end_radius(),
			scale_dist_min      = (near_scan_radius() or 4) - 1.5,
			scale_dist_mid      = (near_scan_radius() or 4) - 0.5,
			scale_dist_max      = (near_scan_radius() or 4),
			los_check_int       = (not cfg.ignore_los) and 250 or nil, -- interval in ms to check LOS to marker object
			los_check_range     = early_scan_radius() + 1,
			custom_argb         = dup_table(cfg.colors.clr_dmark_norm),
			marker_scale        = cfg.dot_marker_size,
			func_anim_take_curve= easing.InSine, -- easing function used for item take animation

			coord_args = { -- zero out all default screen coordinate adjustments
				near_adj = 0, 
				far_adj = 0,
				base_y  = 0,
			},
			-- ================================================================================
			func_on_update = (
			-- ================================================================================
			--      MAIN UPDATE LOOP FOR DOT MARKER OBJECTS
			-- ================================================================================
			--  Called from utils_catspaw_hudmarks at the start of every marker update
			--  Determines prompt and marker visibility for most objects
			--  Updates condition/ammo and other metadata that are visible on prompts
			-- ================================================================================

				function(mark, args)
					if not mark then return end -- literally impossible
					if mark.no_update_loop then return end
					if mark.suspended then return end

					if killswitch("markloop") then
						mark:HideAll("mark loop killswitched")
						return
					end
					local now           = time_global()
					local id            = mark.id
					local obj           = id and get_game_object(id)
					if not obj then return end
					local show_pri      = true
					local dist          = mark.last_dist or 999
					local in_range      = is_in_range(id, dist, mark)
					local vis_range 	= is_in_visible_range(id, dist, mark)
					local abort 		= false
					show_pri, abort 	= update_mark_stalker_health(mark, show_pri, vis_range, in_range)
					if abort then return end

					local hide          = mark.hidden
					local hide_reason 	= hide and "mark itself is hidden" or "none"
					local dd 			= (debug_dump)
					local _             = (not hide) and dump("[%s][%s] Visibility and UI checks for %s | dist %s", mark.id, now, mark.name or mark.tutorial or mark.text, dist)
					
					cfg.in_pickup_range[id] = mark.is_pickup and in_range and dist or nil

					if mark.is_arty and (not mark.arty_container) and (not can_actor_see_artefact(obj)) then
						hide_marker_and_prompts(mark.mark_id, "artefact not visible")
						return
					end
					if mark.is_button and mark.use_pri and mark.use_pri.physbtn_active then
						if not mark.use_pri.physbtn_active() then
							hide_marker_and_prompts(mark.mark_id, "inactive button")
							return
						end
					end

					-- ================================================================================
					-- Check whether this marker is for a junk object
					local sec           = obj:section()
					if (not hide) and obj and zzz_rax_sortingplus_mcm and cfg.sp_hide_junk_items then
						hide_reason = "flagged as junk"
						hide = is_junk(sec)
					end

					-- ================================================================================
					-- Check whether any logic has shut off interaction prompts entirely
					local targeted      = is_current_target(id)
					local show_sec      = false
					local can_display 	= (targeted and in_range)
					show_pri            = show_pri and can_display
					if mark.item_class and not is_object_scannable(mark.item_class) then
						hide_reason = string.format("marking of %s disabled", mark.item_class)
						hide = true
					end
					--dump("prompt check: hide %s | hidden_show: %s | anim block: %s", hide, cfg.hidden_show_prompts, prompt_blocked_by_anim())
					local prompts_shown = false
					local sec_forced 	= (can_display and mark.always_show_sec)
					if (hide and not cfg.hidden_show_prompts) or prompt_blocked_by_anim() then
						--dump("Hiding all prompts")
						hide_mark_prompts(mark)
					else
						-- ================================================================================
						-- Check marker display conditions and whether animations are playing
						-- ================================================================================
						-- Check availability of primary interact prompt
						if mark.use_pri and mark.use_pri.init_done then
							_=dd and dump("Checking whether to show pri interact prompt for %s | targeted %s | in_range %s", mark.name, targeted, in_range)
							if not in_range then
								show_pri = false
							elseif mark.is_npc then
								--dump("%s is an NPC and not a container", mark.name)
								local last_squad = mark.squad_id
								mark.squad_id = obj.group_id
								if mark.squad_id ~= last_squad then
									local squad = mark.squad_id and alife_object(mark.squad_id)
									mark.commander_id = squad and squad:commander_id()
								end
								if (not mark.is_alive) then
									local tracked = true
									local empty = is_empty_mutant_corpse(id)
									if empty then
										-- No need to show markers for empty mutant corpses
										vl("Mutant corpse is empty, destroying marker")
										destroy_marker(mark.mark_id, "empty mutant corpse")
										return
									elseif cfg.bodies_use_mpda_rules and item_milpda then
										-- Hide bodies that Milspec PDA won't show
										tracked = (ish_kill_tracker and ish_kill_tracker.tracked_kill and ish_kill_tracker.tracked_kill(id))
										if not tracked then
											hide_reason = "body hidden by MPDA rules"
											hide = true
										end
									end
								end
							elseif mark.is_container and not mark.is_display then
								-- Update contents of inventory containers
								mark.body_claimed 	= is_body_claimed(id)
								mark.managed_stash 	= not not (mark.body_claimed or is_container_unsearched_stash(id))
								--dump("managed stash: %s | item tbl %s | searched %s", mark.managed_stash, cfg.invboxes[id] and cfg.invboxes[id].items and true or false, cfg.invboxes[id] and cfg.invboxes[id].searched)
								local text = ""
								local num_items = 0
								if (not cfg.invboxes[id]) then
									init_new_inventory_box(id)
								end
								if can_display and not is_invbox_found(id) then
									cfg.invboxes[id].found = true
									mark.is_concealed = false
								end
								--dump("invbox %s | owned %s | found %s", id, cfg.invboxes[id].owned, cfg.invboxes[id].found)
								if not mark.body_claimed then
									if (not cfg.invboxes[id].items) then
										cfg.invboxes[id].items, num_items = get_inventory_table(obj, id)
										_ = debug_dump and vl("[%s] No inventory table for container %s, iterated and found %s items", time_global(), mark.name, num_items)
										if mark.managed_stash and (num_items == 0) then
											-- make treasure manager stashes return as empty until searched
											cfg.invboxes[id].items = nil
										else
											mark.has_items = num_items > 0
										end
									end
								end

								if cfg.show_stash_weight then
									if cfg.invboxes[id].items then
										if mark.has_items then
											mark.weight = axr_companions.get_inventory_weight(cfg.invboxes[id].items)
											local wc = mark.weight and get_actor_weight_class(mark.weight)
											local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
											mark.use_pri.parse_text_colors = true
											text = string.format(" ($%s%.2f %s$clr_def)", code, mark.weight, st_kg)
										else
											text = " " .. gts("st_alti_empty")
										end
									elseif (mark.managed_stash and not cfg.invboxes[id].items) then
										text = " (" .. gts("st_unknown_contents") .. ")"
									else
										text = " " .. gts("st_alti_empty")
									end
									mark.use_pri:SetPrompt(nil, nil, text)
								end
							end
							-- Passed NPC and container checks
							if in_range then
								if mark.is_campfire then
									show_pri = cfg.active_campfire and (cfg.active_campfire == mark.id)
								elseif mark.is_pickup then
									if mark.physics_obj and can_interact_physpickup(id, dist) then
										if (not cfg.available_pickup) then
											cfg.available_pickup = id
										end
										if not pickup_index[id] then
											local i = (#nearby_pickups or 0) + 1
											pickup_index[id] = i
											nearby_pickups[i] = id
										end
									end
									-- Mark is an item pickup
									if cfg.show_item_card then
										mark.use_pri:UpdateWeightColor()
									end
								elseif (not show_pri) then
									local available_pickup = mark.is_pickup and cfg.available_pickup and (mark.id == cfg.available_pickup)
									local not_hidden_by_anim = (cfg.show_prompt_during_anim or not anim_playing)
									-- If nothing else has allowed visibility yet, final checks
									show_pri = (
										(locked_id and targeted) or
										(available_pickup and not locked_id) or
										((not mark.is_pickup) and (targeted)) and
										(dist < 5) and (not mark.is_mute) and
										not_hidden_by_anim
									)
								end
								if mark.show_condition then
									-- Update condition for degradable objects
									update_mark_condition(mark, show_pri)
								end
							end
							_=dd and dump("Final primary interact state: %s | %s", show_pri, nameid(mark.name, mark.id))
							if mark.use_pri then
								mark.use_pri:ShowPrompt(show_pri)
							end
							-- ================================================================================
							-- Check availability of secondary interact prompt
							if mark.alt_interact then
								show_sec = (show_pri and not mark.body_claimed)
								if cfg.hide_sec_interact_ui then
									show_sec        = false
									_=dd and dump("Secondary interactions disabled via config, hiding UI for %s", mark.name)
								elseif show_sec and not sec_forced then
									if mark.ammo_count and (mark.ammo_count == 0) then
										_=dd and dump("No ammo in weapon, hiding secondary interact")
										show_sec    = false
									elseif mark.has_battery and mark.condition and (mark.condition < 0.01) then
										_=dd and dump("No battery or charge in device, hiding secondary interact")
										show_sec    = false
									elseif mark.is_container then
										show_sec    = show_pri and mark.has_items
										_=dd and dump("No items in container, no need to show secondary interact")
									elseif mark.was_wounded then
										show_sec 	= show_pri and validate_wounded_prompt(mark)
									end
									_=dd and dump("Checking whether to show alt interact prompt for %s | show_pri %s | targeted %s", mark.name, show_pri, targeted)
								end
								mark.alt_interact:ShowPrompt(show_sec or sec_forced)
							end
							prompts_shown = show_pri or show_sec or sec_forced
						end
					end

					_=dd and dump("[%s][%s] Done with both prompt checks:\n* final state: %s | show_pri %s | show_sec %s | forced %s", time_global(), mark.name, prompts_shown, show_pri, show_sec, forced_on)
					-- ================================================================================
					local texture = mark.texture or ""
					local no_marker = (hide or cfg.hide_interaction_dots or mark.is_concealed)
					update_marker_active_state(mark, prompts_shown)

					if (not no_marker) and mark.active_swap then
						mark:ActiveSwap(prompts_shown)
						texture = mark.texture
						if mark.use_pri then
							mark.use_pri:SetupConnectingLine()
						end

						if prompts_shown and can_start_popin_anim(mark) then
							init_active_marker_popin(mark)
						end
					end

					if no_marker then
						_=dd and dump("Mark is hidden (%s) clearing texture", hide_reason or "no reason set")
						texture = ""
					else
						mark.marker_scale = cfg.dot_marker_size
						mark:ScaleMarkerByDistance()
					end
					if (texture ~= mark.last_texture) then
						mark.marker:InitTexture(texture)
						mark.last_texture = texture
					end
					log_marker_update_loop(mark)
				end
			),
			-- ================================================================================
			func_los_check = (
			-- ================================================================================
			--  Runs during the LOS check phase of every marker update
			--  Force LOS check to succeed if the marked object is the current interact target
			-- ================================================================================
				--- @param mark utils_catspaw_hudmarks.UIHUDMarker
				--- @param args table
				function(mark, args)
					if not (mark.is_pickup or mark.is_stalker or mark.is_container or mark.is_workshop) then return end
					local pri_shown = (mark and mark.use_pri and mark.use_pri.wnd and mark.use_pri.wnd:IsShown())
					if mark.is_pickup and not pri_shown then
						pri_shown = mark.id and (not not pickup_index[mark.id])
					end
					return pri_shown and true or nil
				end
			),
			-- ================================================================================
			func_on_destroy = (
			-- ================================================================================
			--  When any marker is destroyed, unregister that ID and clear its metadata
			-- ================================================================================
				--- @param mark utils_catspaw_hudmarks.UIHUDMarker
				function(mark)
					if not (mark and mark.id) then return end
					vl("Marker for %s destroyed, unregistering", mark.id)
					local rescan_delay = mark.physics_obj and (cfg.rescan_delay_physobj or 200) or cfg.rescan_delay_all or 0
					this.unregister_scanned_entity(mark.id, rescan_delay)
				end
			),
		}
		-- Most static values are loaded from the cfg.dotmark_preset table, thus loaded from the config file
		for k,v in pairs(cfg.dotmark_preset) do
			preset_args[k] = v
		end
		return preset_args
	end
)

function update_mark_condition(mark, prompt_shown)
	local id = mark and mark.id
	local obj = id and get_game_object(mark.id)
	if not obj then return end
	local is_world = game_setup.is_world_item(id)
	if prompt_shown and is_world and (not mark.world_obj_cond) then
		-- Loose loot spawned in the world doesn't actually have condition or other metadata
		-- until the actor picks them up for the first time
		-- So we need to instantiate it the first time the prompt is displayed
		local name = id and game_setup.world_itm_on and game_setup.world_itm_on[id]
		local cond = name and game_setup.world_itm_num and game_setup.world_itm_num[name]
		dump("Condition %s loaded for degraded world item [%s] from loot spot [%s]", cond, nameid(obj), name)
		mark.world_obj_cond = cond
	end	
	local cond = (not is_world) and obj:condition() or mark.world_obj_cond
	if mark.use_pri and cond and (cond ~= mark.condition) then
		vl("Updating marker condition for %s", nameid(obj))
		mark.condition = cond
		mark.use_pri:SetConditionText(mark.section, cond)
		mark.use_pri:SetPrompt()
	end
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param show_pri boolean
--- @param vis_range number
--- @param in_range boolean
function update_mark_stalker_health(mark, show_pri, vis_range, in_range)
	if mark and mark.is_stalker and mark.is_alive then
		local id = mark.id
		local obj = get_game_object(id)
		if not obj then return end
		local alive = obj:alive()
		if not alive then
			handle_npc_death(obj, nil, "update loop")
			return false, true
		end
		mark.is_wounded = xr_wounded.is_wounded(obj) or nil
		mark.is_enemy   = mark.comm and game_relations.is_factions_enemies(cfg.actor_comm, mark.comm)
		mark.is_mute    = not obj:is_talk_enabled()
		mark.hidden     = (mark.hidden and mark.is_mute) or (mark.is_enemy and not mark.is_wounded)
		--dump("%s is %s NPC | enemy %s | wounded %s was %s | mute %s", mark.name, mark.comm, mark.is_enemy, mark.is_wounded, mark.was_wounded, mark.is_mute)
		if mark.is_wounded then
			if not (mark.was_wounded or cfg.heal_cooldown_active) then
				mark.vis_ignore_mute 	= vis_ignore_mute(id)
				mark.was_wounded 		= true
				if mark.is_enemy then
					-- do nothing at this time, enemies with surrender dialog can talk
				else
					set_secondary_action(mark)
				end
			end
		elseif mark.was_wounded then
			end_mark_wounded_state(mark)
		end
		--dump("Mute check for %s: %s | in_range %s | vis_range %s | vis_ignore %s", mark.name, mark.is_mute, in_range, vis_range, mark.vis_ignore_mute)
		local mute_hide = not (mark.vis_ignore_mute and vis_range and not in_range)
		if mark.is_mute and mute_hide then
			show_pri = false
			if cfg.hide_mute_stalkers then
				hide_marker_and_prompts(mark.mark_id, "mute stalker")
				return false, true
			end
		end
	end
	return show_pri, false
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param state boolean
function update_marker_active_state(mark, state)
	if mark and (mark.is_active ~= state) then
		vl("[%s][%s] Mark active status changed to %s (was %s)", time_global(), mark.name, state, mark.is_active)
		mark.last_active_state = mark.is_active
		mark.is_active = state
		mark.next_update = 0
	end
end

-- ======================================================================
--      ACTIVE SWAP OF MARKER ATTRIBUTES
--  Monkeypatches utils_catspaw_hudmarks to add support for hotswapping
--  the marker texture and other parameters on the fly based on states
-- ======================================================================
--- @param state boolean
function utils_catspaw_hudmarks.UIHUDMarker:ActiveSwap(state)
	dump("[%s][UIHUDMarker:ActiveSwap] for %s: %s", time_global(), self.name or self.tutorial, state)
	if self.destroyed then return end
	if not (self.active_swap or self.task_swap) then return end
	local is_task_target= match_squad_or_leader(self.args.id, cfg.active_task_target_id) and cfg.enable_icon_tasks
	local is_storyline  = to_bool(utils_catspaw_taskmonitor and utils_catspaw_taskmonitor.is_task_storyline())
	local last_swap     = self.task_swap or self.active_swap
	self.task_swap      = is_task_target and dup_table(is_storyline and cfg.swap_task_pri or cfg.swap_task_sec) or nil
	if state == nil then state = is_current_target(self.id) end
	local _
	if state then
		for k,v in pairs(self.task_swap or self.active_swap) do
			if (popin_active ~= self.mark_id) then
				_ = debug_dump and vl("[%s][%s][Swap on] Setting: %s = %s", time_global(), self.name, k, v)
				self[k] = v
				if self.use_pri then
					self.use_pri.args[k] = v
				end
			end
		end
	else
		for k,v in pairs(last_swap or self.active_swap) do
			self.popin_done = false
			self[k] = self.args[k]
			if self.use_pri then
				self.use_pri.args[k] = self.args[k]
			end
			_ = debug_dump and vl("[%s][%s][Swap off] Reverting: %s = %s", time_global(), self.name, k, self.args[k])
		end

	end
	self.base_w = self.width
	self.base_h = self.height

end

-- ======================================================================

function is_system_active()
	return scanning and not killswitch("markloop")
end

--- @param id number
function get_mark(id)
	return id and cfg.markers[id]
end

--- @param id number
--- @param bone string
function set_mark_bone(id, bone)
	local mark = get_mark(id)
	if not mark then return end
	mark.bone = bone
end

--- @param id number
--- @param by_whom game_object
function use_obj_by_id(id, by_whom)
	local obj = id and get_object_by_id(id)
	if not obj then return end
	obj:use(by_whom or db.actor)
end

--- @param id number
function get_mark_name(id)
	local mark = get_mark(id)
	return mark and mark.name
end

--- @param i number
function uiscale(i)
	return (i or 0) * (cfg.ui_scale or 1)
end

--- @param num number
function get_font(num)
	return fonts[tonumber(num) or cfg.font_main_prompt or fallback_font]
end

--- @param num number
function get_font_obj(num)
	local font = get_font(num)
	return font and font.font
end

--- @param num number
function get_font_xoff(num)
	local font = get_font(num)
	return font and tonumber(font.xoff) or 0
end

--- @param num number
function get_font_width(num)
	local font = get_font(num)
	return font and tonumber(font.width or font.size) or 16
end

--- @param num number
function get_font_height(num)
	local font = get_font(num)
	return font and tonumber(font.height or font.width or font.size) or 16
end

--- @param num number
function get_font_scale_w(num)
	local scale = (get_font_width(num) / 16) * (cfg.font_scale_w or 1)
	return scale
end

--- @param num number
function get_font_scale_h(num)
	local scale = (get_font_height(num) / 16) * (cfg.font_scale_h or 1)
	return scale
end

--- @param i number
function fontscale_w(i)
	return i * get_font_scale_w(num)
end

--- @param i number
function fontscale_h(i)
	return i * get_font_scale_h(num)
end

--- @param element CUIStatic
--- @param x number
--- @param y number
function setwndpos(element, x, y)
	if not element then return end
	element:SetWndPos(vector2():set(
		uiscale(x or 0),
		uiscale(y or 0)
	))
end

--- @param element CUIStatic
--- @param w number
--- @param h number
function setwndsize(element, w, h)
	if not element then return end
	element:SetWndSize(vector2():set(
		uiscale(w or 0),
		uiscale(h or 0)
	))
end

function update_mark_radii()
	for id,mark in pairs(cfg.markers) do
		if mark.mark_id then
			mark.far_fade_dist      = near_scan_radius() - 1
			mark.far_end_dist        = early_scan_radius() + 5
			mark.scale_dist_min      = (near_scan_radius() or 4) - 1.5
			mark.scale_dist_mid      = (near_scan_radius() or 4) - 0.5
			mark.scale_dist_max      = (near_scan_radius() or 4)
			mark.los_check_range     = early_scan_radius() + 1
		end
	end
end

function get_scavenging_display_string()
	if cfg.use_skill_system then
		local loc = gts("st_skills_stats_dotmark_bonus_range")
		local val = cfg.skill_bonus_range or 0
		local str = psk(loc, {["stat"] = val})
		return str
	else
		return ""
	end
end

--- @param id number
function vis_ignore_mute(id)
	-- More or less a refactoring of xr_meet.process_npc_usability
	local npc = get_game_object(id)
	if not npc then return end

	local comm = character_community(npc)
	if (comm == "zombied") then return false end
	local st = id and db.storage[id]

	if IsWounded(npc) then
		if (npc:relation(db.actor) >= game_object.enemy and st and st.victim_surrender ~= AC_ID) then
			return false
		else
			local wounded = st and st.wounded
			if wounded and wounded.enable_talk then
				return true
			else
				return false
			end
		end
		return
	end

	local section = npc:section()
	if (section == "mar_smart_terrain_doc_doctor") then return true end

	local meet = st and st.meet
	if not meet then return end

	local use = meet.meet_manager and meet.meet_manager.use
	if (use == "true") then
		if xr_corpse_detection.is_under_corpse_detection(npc) or xr_help_wounded.is_under_help_wounded(npc) then
			return false
		else
			return true
		end
		return
	end

	local task_info = task_manager.get_task_manager().task_info
	for k,v in pairs(task_info) do
		if (v.task_giver_id and v.task_giver_id == id) then
			return true
		elseif tasks_delivery.is_delivery_task(k) then
			local var = load_var(db.actor, k)
			if var and var.target_id and (var.target_id == id) then
				return true
			end
		end 
	end
	local leader = is_squad_leader(npc)
	if (not leader) and (not cfg.all_squad_members_talk) then
		return false
	end
	return true
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function get_interact_distance(id, mark)
	if not mark then mark = get_mark(id) end
	return mark and mark.interact_dist or cfg.obj_interact_dist or 2.5
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function get_visible_distance(id, mark)
	return mark and (mark.far_fade_dist + mark.far_hide_dist) or 999
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function get_mark_dist(id, mark)
	local dist
	if (not mark) then
		local obj = id and get_game_object(id)
		if not (obj and db.actor) then return end
		dist = db.actor:position():distance_to(obj:position())
	end
	return dist and dist or (mark and mark.last_dist) or 999
end

--- @param id number
--- @param dist number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function is_in_range(id, dist, mark)
	dist = dist or get_mark_dist(id, mark)
	return dist <= get_interact_distance(nil, mark)
end

--- @param id number
--- @param dist number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function is_in_visible_range(id, dist, mark)
	dist = dist or get_mark_dist(id, mark)
	return dist <= get_visible_distance(id, mark)
end

--- @param id number
--- @param active_check boolean
function get_ied_mode(id, active_check)
	local data = id and txr_mines._mines[id]
	local mode = data and data.mode
	if active_check and mode then
		mode = data.active and mode or nil
	end
	return mode
end

--- @param id number
function get_remaining_ied_time(id)
	local data = id and txr_mines._mines[id]
	local mode = data and data.mode
	if (mode == cfg.mine_modes.MODE_TIMER) then
		local now = get_time_elapsed()
		local left = data.exp_time - now
		return left, mode
	end
	return nil, mode
end

--- @param gametime number
function game_seconds(gametime)
	return gametime and (gametime > 0)  and (gametime / level.get_time_factor())
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param args table
function is_still_wounded(mark, args)
	return mark and mark.is_wounded
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param args table
function validate_wounded_prompt(mark, args)
	if not mark then return end
	if not cfg.healing_stalker then
		if mark.is_wounded then
			return not not mark.alt_interact.avail_aid
		elseif mark.was_wounded then
			end_mark_wounded_state(mark)
		end
	end
end

--- @param state boolean
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function ied_anim_cycle_func(state, mark)
	-- none of this currently works properly
	if not mark then return end
	local id = mark.id
	local data = id and txr_mines._mines[id]
	local mode = data and data.mode
	local now = get_time_elapsed()
	local boom = data and data.exp_time
	local left = boom and (boom - now)
	local secs = game_seconds(left)
	local cycle = 1
	local dgr = (txr_mines.TRIGGER_RADIUS or 2.5) + 2.5
	local tooclose = mark.last_dist and mark.last_dist < dgr
	local anim = active_anims[mark.mark_id].ied
	if (mode == 0) then
		local dist = clamp(tonumber(mark.last_dist) or 10, 5, 10)
		local max = 10
		local warn = lerp(2.5, 10, dist)
		anim.cycle_dur = 1000 - (warn * 850)
	elseif (mode == 1) then
		if secs < 10 then
			if (secs < 5) then
				cycle = (state % 0.25)
			elseif (state < 0.4) then
				cycle = (state % 0.2)
			else
			end
		end
	end

	eased = easing.easeOutElastic(cycle)
	--("[%s] ied_anim_cycle_func: state %s | cycle %s | eased %s", time_global(), state, cycle, eased)
	return eased
end

--- @param mark_id string
--- @param w_start number
--- @param h_start number
--- @param w_end number
--- @param h_end number
--- @param duration number
--- @param anim_func function
--- @param on_finish_func function
--- @param abort_func function
function do_marker_anim_cycle(
		mark_id,
		w_start, h_start, w_end, h_end, duration,
		anim_func, on_finish_func, abort_func
	)
	-- This was only used in a now-abandoned feature, but has potential for reuse
	if not mark_id then return end
	local anim_state 	= 0
	local anim_id 		= mark_id .. "_popin"
	local mark      	= hmm:GetMarker(mark_id)
	if not mark then return end

	if not active_anims[mark_id] then
		active_anims[mark_id] = {}
	end

	local start_time= time_global()
	local end_time  = time_global() + duration

	anim_func = anim_func or function(x) return x end
	active_anims[mark_id].ied = {
		mark_id     = mark_id,
		anim_id     = anim_id,
		active      = true,
		cycle_dur 	= duration,
		w_start     = function(mark) return mark and mark.is_active and mark.args.width or w_start or 0 end,
		w_end       = function(mark) return mark and mark.is_active and mark.active_swap.width or mark.args.width or w_end or 0 end,
		h_start     = function(mark) return mark and mark.is_active and mark.args.height or h_start or 0 end,
		h_end       = function(mark) return mark and mark.is_active and mark.active_swap.height or mark.args.height or h_end or 0 end,
	}
	
	
	CreateTimeEvent("animate_ied_"..mark_id, time_global(), 0, 
		function()
			local now = time_global()
			if abort_func and abort_func() then
				anim_state = -1
			else
				local anim = active_anims[mark_id].ied
				local mark = hmm:GetMarker(mark_id)
				if not mark then
					anim_state = -1
				elseif anim and anim.active then
					if now > end_time then
						anim_state = 1
						start_time = now
						end_time = now + anim.cycle_dur
					end

					local x = anim_func(anim_state, mark) or 1
					anim.w = lerp(anim.w_start(mark), anim.w_end(mark), x)
					anim.h = lerp(anim.h_start(mark), anim.h_end(mark), x)
					mark.base_w = anim.w or anim.w_end(mark)
					mark.base_h = anim.h or anim.h_end(mark)
					set_adjusted_marker_size(mark_id)
				else
					anim_state = -1
				end
			end

			if (anim_state == -1) then
				if on_finish_func then on_finish_func() end
				active_anims[mark_id].ied = nil
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

function get_ied_text()
	if cfg.mine_mode < 0 then return end
	local timer = (cfg.mine_mode == 1) and (cfg.bomb_timer or 30) or ""
	local iedstr = "ui_mcm_lst_dmarks_iedmode_"..tostring(cfg.mine_mode)
	local iedtext = gts(iedstr)
	if (cfg.mine_mode == 1) then
		iedtext = string.format(iedtext, timer)
	end
	
	dump("get_ied_text: mode %s | timer %s | str %s | text %s", cfg.mine_mode, timer, iedstr, iedtext)
	return iedtext
end

--- @param obj game_object
function IsWounded(obj)
	local var = load_var(obj, "wounded_state")
	return var and (var ~= "") and (var ~= "nil")
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function end_mark_wounded_state(mark)
	vl("end_mark_wounded_state for %s", mark and mark.name)
	if not (mark and mark.is_stalker and mark.alt_interact) then return end
	mark.is_wounded = nil
	mark.was_wounded = nil
	cfg.healing_stalker = nil
	mark.checked_for_sec = nil
	mark.vis_ignore_mute = vis_ignore_mute(id)
	if mark.alt_interact then
		mark.alt_interact:Destroy("NPC is no longer wounded")
	end
	cfg.heal_cooldown_active = true
	CreateTimeEvent("dmark_heal_cooldown", 0, 2, (
		function()
			cfg.heal_cooldown_active = false
			return true
		end
	))
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function log_marker_update_loop(mark)
	mark.loop_num = mark.loop_num and (mark.loop_num + 1) or 0
	local _ = debug_dump and vl("[DotMarks] [%s][%s] End of main update loop %s | Final size: [%s x %s]", time_global(), mark.name, mark.loop_num, dec2(mark.width), dec2(mark.height))
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function hide_mark_prompts(mark)
	if not mark then return end
	if mark.use_pri then
		mark.use_pri:ShowPrompt(false)
	end
	if mark.alt_interact then
		mark.alt_interact:ShowPrompt(false)
	end
end

--- @param mark_id string
--- @param reason string
function hide_marker_and_prompts(mark_id, reason)
	local mark = mark_id and hmm:GetMarker(mark_id)
	if not mark then return end
	hide_mark_prompts(mark)
	if mark.last_texture ~= "" then
		mark.marker:InitTexture("")
		mark.last_texture = ""
	end
	mark:HideAll(reason or "hide_marker_and_prompts called")
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function suspend_marker(mark)
	if not mark then return end
	dump("Suspending marker for %s", mark.name or mark.tutorial)
	mark.suspended = true
	hide_marker_and_prompts(mark.mark_id, "marker suspended")
end

--- @param mark_id string
--- @param reason string
function destroy_marker(mark_id, reason)
	local _ = debug_dump and dl("Trying to destroy marker %s%s", mark_id, reason and (" | "..reason) or "")
	local mark = hmm:GetMarker(mark_id)
	if mark then mark:Destroy(nil, reason) end
end

--- @param tid string
--- @param reason string
function destroy_prompt(tid, reason)
	local _ = debug_dump and dl("Trying to destroy tutorial prompt %s%s", tid, reason and (" | "..reason) or "")
	local mark = tid and cfg.markers[tid]
	if mark then
		mark:Destroy(nil, reason)
		cfg.markers[tid] = nil
	end
end

--- @param feature string
function killswitch(feature)
	if cfg.killswitch_all then return true end
	if feature then
		feature = ("killswitch_" .. feature)
		return not not cfg[feature]
	end
end

function input_killswitch()
	return cfg.killswitch_all or cfg.killswitch_input
end

--- @param flag boolean
--- @param feature string
function set_killswitch(flag, feature)
	local killswitch = "killswitch_" .. (feature or "all")
	cfg[killswitch] = not not flag
end

--- @param and_shut_down boolean
function suspend(and_shut_down)
	dl("Attempting to %s DotMarks", and_shut_down and "shut down" or "suspend")
	scanning = false
	set_killswitch(true)
	ui_hud_dotmarks.set_handler_callbacks(and_shut_down)
	for k,v in pairs(cfg.markers) do
		suspend_marker(v)
	end
end

function resume()
	dl("Attempting to resume DotMarks operations")
	scanning = true
	set_killswitch(false)
	ui_hud_dotmarks.set_handler_callbacks()
	for k,v in pairs(cfg.markers) do
		v.suspended = false
	end
end

function shut_down()
	suspend(true)
	for k,v in pairs(cfg.markers) do
		if v.mark_id then
			destroy_marker(v.mark_id)
		else
			v:Destroy("shutting down")
		end
	end
end

function get_fddar_current_action()
	return lam2 and lam2.get_current_action()
end

function fddar_update_current_anim_state()
	anim_playing = lam2 and lam2.is_running()
end

function get_fdda_callback()
	fdda_callback = fdda_pickup and fdda_pickup.get_fdda_oibp_callback and fdda_pickup.get_fdda_oibp_callback() or nil
	return fdda_callback or (function() return false end)
end

function fdda_handles_pickups()
	return get_fdda_callback() and (cfg.fdda_pickup_anim or cfg.fddar_pickup_anim)
end

--- @param obj game_object
--- @param flags table
function item_pickup_intercept(obj, flags)
	dump("item_pickup_intercept fired | ret: %s | force: %s", flags and flags.ret_value, flags and flags.force)
	if killswitch("pickup") then
		if fdda_handles_pickups() then get_fdda_callback(obj, flags) end
		return
	end
	-- Called directly by actor_on_item_before_pickup if neither FDDA nor FDDAR are installed
	-- Called by my monkeypatch of FDDA/FDDAR's pickup if they are
	local now = time_global()
	if flags.force then
		-- Skip all other input checks
	else
		if (cfg.held_key == use_dik) then
			flags.ret_value = false
			return
		elseif cfg.watch_use then
			if recent_long_press() then
				flags.ret_value = false
				return
			end
		end
	end

	vl("[%s][ret_val: %s][item_pickup_intercept] Actor tried to take item %s", now, flags.ret_value, nameid(obj))

	local curr_target, taken_obj
	curr_target = get_current_target()
	taken_obj = curr_target and get_game_object(curr_target)
	
	if taken_obj then
		dl("[%s][item_pickup_intercept] Actor will take item %s", now, nameid(taken_obj))
		local handle_take = flags.skip_anim or not fdda_callback
		if flags.ret_value then
			dump("flags.ret_value is true, setting to false")
			flags.ret_value = false
			local mark = cfg.markers[curr_target]
			if handle_take and not (mark and mark.physics_obj) then
				vl("flags.ret_value is %s, DotMarks will handle pickup %s", flags.ret_value, nameid(taken_obj))
				db.actor:take_item(taken_obj)
				return
			end
			if mark then
				mark:HideAll("dotmarks taking item")
			end
			fake_take_anim(mark)
			return
		end
		dump("flags.ret_value was false, returning object")
	end
	return taken_obj
end

--- @param mark_id string
function set_adjusted_marker_size(mark_id)
	local mark = hmm:GetMarker(mark_id)
	if not mark then return end
	mark.width = mark.base_w
	mark.height = mark.base_h
	--dump("[%s] set_adjusted_marker_size for %s: %s,%s", time_global(), mark.name, mark.width, mark.height)
	if mark.use_pri then
		mark.use_pri:UpdateMainWndPos(mark)
	end
	if mark.alt_interact then
		mark.alt_interact:UpdateMainWndPos(mark)
	end
end

--- @param mark_id string
--- @param w_start number
--- @param h_start number
--- @param w_end number
--- @param h_end number
--- @param duration number
--- @param easing_func function
--- @param on_finish_func function
--- @param abort_func function
function do_marker_popin(
		mark_id,
		w_start, h_start, w_end, h_end, duration,
		easing_func, on_finish_func, abort_func
	)
	if not mark_id then return end

	local anim_state = 0

	local anim_id = mark_id .. "_popin"

	if not active_anims[mark_id] then
		active_anims[mark_id] = {}
	end
	if active_anims[mark_id].popin then
		popin_active = nil
	end
	popin_active = mark_id

	local mark      = hmm:GetMarker(mark_id)
	if not mark then return end

	local start_time= time_global()
	local end_time  = time_global() + duration

	easing_func = easing_func or function(x) return x end
	active_anims[mark_id].popin = {
		mark_id     = mark_id,
		anim_id     = anim_id,
		start_time  = start_time,
		end_time    = end_time,
		active      = true,
		w_start     = function(mark) return mark and mark.is_active and mark.args.width or w_start or 0 end,
		w_end       = function(mark) return mark and mark.is_active and mark.active_swap.width or mark.args.width or w_end or 0 end,
		h_start     = function(mark) return mark and mark.is_active and mark.args.height or h_start or 0 end,
		h_end       = function(mark) return mark and mark.is_active and mark.active_swap.height or mark.args.height or h_end or 0 end,
	}
	
	
	CreateTimeEvent("animate_popin_"..mark_id, time_global(), 0, 
		function()
			local abort = abort_func and abort_func()
			if abort then
				anim_state = 1
			elseif start_time - end_time > 5000 then
				-- Timeout to catch orphaned timeevents
				anim_state = 1
			else
				local anim = active_anims[mark_id].popin
				local mark = hmm:GetMarker(mark_id)
				if not (mark and mark.is_shown) then
					anim_state = 1
				elseif mark and anim and anim.active then
					if mark.is_active then
						local x = easing_func(anim_state)
						anim.w = lerp(anim.w_start(mark), anim.w_end(mark), x)
						anim.h = lerp(anim.h_start(mark), anim.h_end(mark), x)
					else
						anim_state = 1
					end
					mark.base_w = anim.w or anim.w_end(mark)
					mark.base_h = anim.h or anim.h_end(mark)
					set_adjusted_marker_size(mark_id)
				else
					anim_state = 1
				end
			end

			if (anim_state == 1) then
				if on_finish_func then on_finish_func() end
				active_anims[mark_id].popin = nil
				popin_active = nil
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function init_active_marker_popin(mark)
	if type(mark) == "string" then
		-- Assume a mark_id got passed instead of the mark itself
		mark = hmm:GetMarker(mark)
	end
	if not (mark and mark.mark_id) then return end

	do_marker_popin(
		mark.mark_id,
		mark.args.width * 0.5, mark.args.height * 0.5,
		mark.active_swap.width, mark.active_swap.height,
		cfg.popin_anim_dur,
		easing.easeOutElastic,
		(function()
			mark.next_update = 0
			mark.popin_done = true
			popin_active = nil
		end),
		(function() 
			return  (not popin_active) or
					(not mark.texture) or
					(popin_active ~= mark.mark_id) or
					(mark.texture ~= mark.active_swap.texture)
		end)
	)
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function can_start_popin_anim(mark)
	return cfg.popin_anim_dur and (cfg.popin_anim_dur > 0) and not (popin_active or mark.popin_done)
end

--- @param id number
--- @param comp_id number
function match_squad_or_leader(id, comp_id)
	if (id == comp_id) then return true end
	local se_obj    = comp_id and alife_object(comp_id)
	local cls       = se_obj and se_obj:clsid()
	local is_squad  = cls and (cls == clsid.online_offline_group_s) or (cls == clsid.online_offline_group)
	if is_squad then
		-- If the comparison ID is a squad object and didn't match directly, compare to its commander_id
		local leader_id = se_obj:commander_id()
		return (id == leader_id)
	end
end

--- @param obj game_object
function can_actor_see_artefact(obj)
	local arty  = obj and obj:cast_Artefact()
	local vstate= arty and arty.getVisible and arty:getVisible() or 0
	local _ = debug_dump and vl("can_actor_see_artefact for %s: %s", nameid(obj), (vstate == 1) and true or false)
	return (vstate == 1) and true or false
end

--- @param obj game_object
function get_bones_for_obj(obj)
	local bones = obj and obj.list_bones and obj:list_bones()
	return bones
end

--- @param obj game_object
function has_parts(obj)
	if not obj then return end
	local sec = SYS_GetParam(0, obj:section(), "parent_section") or obj:section()
	local parts = ini_parts:r_string_ex("con_parts_list", sec)
	return parts ~= nil
end

--- @param obj game_object
--- @param id number
function is_door_open(obj, id)
	id = id or (obj and obj:id())
	obj = obj or (id and get_game_object(id))
	if not id then return end
	local door = id and db.storage[id]["ph_door"] and db.storage[id]["ph_door"].door_action
	local is_open = door:is_open()
end

function is_vanilla_ui_hidden()
	return (cfg.hide_van_interact_ui and not cfg.hide_pri_interact_ui)
end

--- @param txt string
function trimmed_prompt(txt)
	local pos = txt and txt:find("%(")
	return pos and txt:sub(1, pos - 2) or txt or ""
end

--- @param ui_interact InteractPrompt
function interact_vert_offset(ui_interact)
	local args = ui_interact and ui_interact.args
	return args and (not args.pri) and (not cfg.hide_pri_interact_ui) and cfg.sec_use_y_offset or cfg.pri_use_y_offset
end

--- @param val number
--- @param val mi
--- @param val md
--- @param val mx
function lerp_color(val, mi, md, mx)
	-- like in utils_xml, except returning a table I can do something with instead of ARGB
	local m1,m2
	if (val >= mi[5]) and (val < md[5]) then
		m1 = mi
		m2 = md
	elseif (val >= md[5]) and (val <= mx[5]) then
		m1 = md
		m2 = mx
	end
	if not (m1 and m2) then
		return clr_tbl(255,255,255,255)
	end
	
	local t = {}
	for i=1,4 do
		if m1[i] == m2[i] then
			t[i] = m1[i]
		else
			t[i] = math.floor( m1[i] + ((m2[i] - m1[i]) * normalize(val, m1[5], m2[5])) )
		end
	end
	return clr_tbl(t[1], t[2], t[3], t[4])
end

--- @param id number
function is_already_target(id)
	local is_pickup = hmm and hmm.current_pickup and (id == hmm.current_pickup)
	if is_pickup then return true end
	local is_target = hmm and hmm.current_target and (id == hmm.current_target)
	if is_target then return true end
	local is_xhair  = hmm and hmm.current_pickup and (id == hmm.current_crosshair)
	if is_xhair then return true end
end

--- @param condition number
--- @param section string
function get_condition_color(condition, section)
	if not condition then return end
	local args      = {}
	local c         = cfg.colors
	local mode      = 0
	local crit_pwr  = section and item_device.dev_critical[section]
	if crit_pwr then
		mode        = 2
		args.crit   = crit_pwr
	elseif cfg.parts_wpo_colors then
		mode        = 1
	else
		condition   = clamp(tonumber(condition) or 1 / 99, 0, 1)
	end
	return get_state_color(condition, mode, args)
end

--- @param stamp number
--- @param interval number
--- @param now number
function timed_out(stamp, interval, now)
	if not (stamp and interval) then return end
	return ((now or time_global()) - stamp) >= interval
end

--- @param id number
function can_show_part_dots(id)
	if not cfg.show_part_condition then return end
	if not (z_item_icon_info and item_icon_info_mcm) then return end
	local obj = get_game_object(id)
	if not (obj and has_parts(obj)) then return end
	return true
end

function get_quickhelp_text()
	local text = maingameui and maingameui.UIStaticQuickHelp and maingameui.UIStaticQuickHelp:GetText()
	return text and (text ~= "") and (text ~= " ") and text or nil
end

--- @param text string
function set_quickhelp_text(text)
	if not maingameui and maingameui.UIStaticQuickHelp then return end
	maingameui.UIStaticQuickHelp:SetText(text or "")
end

--[[======================================================================
	Custom interaction prompt
	Review at some point post-release for unused args/code
-- =====================================================================]]

class "InteractPrompt" (CUIScriptWnd)
-- =======================================================================
--- @param anchor CUIStatic
--- @param args table
function InteractPrompt:__init(anchor, args) super()
	vl("InteractPrompt:__init | event %s | name %s | tutorial %s", args and args.event, args and args.name, args and args.tutorial)
	self:SetAutoDelete(true)
	self.elements = {
		["wnd"]         = true,
		["drop"] 		= true,
		["prompt"]      = false,
		["prompt_l"]    = false,
		["prompt_c"]    = false,
		["prompt_r"]    = false,
		["bind"]        = true,
		["bind_sh"]     = true,
		["label"]       = true,
		["label_sh"]    = true,
		["line"]        = false,
		["longpress"]   = false,
	}   -- bool is whether to scale alpha during fades
	self.xml    = CScriptXmlInit()
	self.uid    = "dotmarks_" .. args.event
	self:ParseArgs(args)
	-- ===================================================================
	--	Setup special handlers and hint filters
	-- ===================================================================
	self.anchor 	= self.args.fixed and maingameui or anchor or maingameui
	if self.args.fixed then
		local x,y   = get_fixed_screen_pos()
		self.args.locked_screen_pos = vector2():set(x, y)
	end
	if self.args.scheme then
		if self.args.is_button then
			self:SetupButtonHandlers()
		elseif self.args.scheme == "ph_door" then
			self:SetupDoorHandlers()
		end
	end
	if self.args.tutorial then
		if (self.args.tutorial:find("campfire")) then
			self.campfire_tut   = true
		elseif (self.args.tutorial == "tutorial_sleep") then
			self.sleep_tut = true
		end
	end	
	self:SetupHintFilters()
	-- ===================================================================
	-- 	Setup text and prompts, finish init
	-- ===================================================================
	local color             = cfg.colors
	local csv2clr           = csv_argb_to_tbl
	self.text_color_default = clr_tbl(255, 255, 255, 255)
	self.text_hidden        = clr_tbl(0, 0, 0, 0)
	self.text_color_busy    = csv2clr(args.argb_busy)   or color.clr_text_busy  or self.text_color_default
	self.text_color_light   = csv2clr(args.argb_light)  or color.clr_text_light or self.text_color_default
	self.text_color_dark    = csv2clr(args.argb_dark)   or color.clr_text_dark  or self.text_color_default
	self.progress_color     = csv2clr(args.argb_prog)   or color.clr_key_hold or csv_argb_to_tbl({255,255,215,0})
	self.active_prefix      = args.active_prefix or args.act    or ""
	self.active_prompt      = args.active_prompt or args.text   or (args.tutorial and trimmed_prompt(gts(args.tutorial))) or ""
	self.active_suffix      = args.active_suffix or args.suffix or ""
	self.last_state         = false
	self:on_option_change()
	self:BusyState(false)
	self:ShowPrompt(args.begin_active, "init")
	-- ===================================================================
	RegisterScriptCallback("actor_on_net_destroy", self)
	RegisterScriptCallback("on_option_change", self)
	RegisterScriptCallback("actor_on_update", self)
	vl("[%s][InteractPrompt] Completed setup for prompt: %s", self.init_done, self:GetFullPrompt())
end
-- =======================================================================

--- @param bind number
function InteractPrompt:CycleBombMode(bind)
	if self.disabled or (not self.args.iedtext) then return end
	local max = cfg.rce_installed and 2 or 1
	if bind == cfg.bind_fmnext then
		cfg.mine_mode = cfg.mine_mode + 1
		if cfg.mine_mode > max then cfg.mine_mode = 0 end
	else
		cfg.mine_mode = cfg.mine_mode - 1
		if cfg.mine_mode < 0 then cfg.mine_mode = max end
	end
	play_snd_path(cfg.snd_path_blip)
	self.active_prompt = self.args.iedtext .. " " .. get_ied_text()
	self:SetPrompt()
end

--- @param direction number
function InteractPrompt:SetBombTimer(direction)
	if self.disabled or (not self.args.iedtext) then return end
	local min = cfg.bomb_timer_min or 10
	local max = cfg.bomb_timer_max or 120
	local inc = cfg.bomb_timer_inc or 5

	cfg.bomb_timer = (cfg.bomb_timer or 30) + (direction * inc)
	if cfg.bomb_timer > max then
		cfg.bomb_timer = min
	elseif cfg.bomb_timer < min then
		cfg.bomb_timer = max
	end
	play_snd_path(cfg.snd_path_blip)
	self.active_prompt = self.args.iedtext .. " " .. get_ied_text()
	self:SetPrompt()
end

--- @param scroll_dir number
--- @param flags table
function InteractPrompt:on_mouse_wheel(scroll_dir, flags)
	if input_killswitch() then return end
	if not cfg.sec_use_mousewheel_timer then return end
	local id = targeted_deployable_bomb()
	if not id then return end
	local direction = (scroll_dir > 0) and 1 or -1
	self:SetBombTimer(direction)
	flags.ret_value = false
end

--- @param key number
--- @param bind number
--- @param dis boolean
--- @param flags table
function InteractPrompt:on_before_key_press(key, bind, dis, flags)
	if input_killswitch() then return end
	dump("InteractPrompt:on_before_key_press | key %s | bind %s", key, bind)
	if self.args.iedmode then
		if cfg.sec_use_firemode_mines and ((bind == cfg.bind_fmprev) or (bind == cfg.bind_fmnext)) then
			local id = targeted_deployable_bomb()
			if not id then return end
			self:CycleBombMode(bind)
			flags.ret_value = false
		end
	elseif (bind == key_bindings.kUSE) then --and cfg.watch_use then
		if self.args.is_glowstick or can_interact_physpickup(self.args.id) then
			local obj = get_game_object(self.args.id)
			vl("Forcing actor to take physics pickup %s", self.args.name)
			flags.ret_value = false
			item_pickup_intercept(obj, {force = true, ret_value = true, skip_anim = skip_anim})
			self:Destroy("actor took physics object")
		end
	end
end

--- @param args table
function InteractPrompt:ParseArgs(args)
	if debug_dump then
		dump("[InteractPrompt] Passed args:")
		for k,v in pairs(args) do dump("|| %s = %s", k, v) end
	end
	args        = args or {}
	args.func   = args.func or (function() end)
	args.event  = self:Event(args.event)
	args.key    = self:BindKey(args.key)
	args.mod    = self:ModKey(args.mod)
	args.mode   = self:InputMode(args.mode)
	args.bind   = args.bind or bindtext(key, mod)
	args.long   = args.long or (args.mode == 2)
	args.xoffset= args.xoffset or (args.pri and cfg.pri_use_x_offset or cfg.sec_use_x_offset) or 0
	args.yoffset= args.yoffset or (args.pri and cfg.pri_use_y_offset or cfg.sec_use_y_offset) or 0
	if (not args.no_sec_yscale) and (not args.pri) then
		local pxoff = cfg.pri_use_x_offset
		local pyoff = cfg.pri_use_y_offset
		local sxoff = cfg.sec_use_x_offset
		local syoff = cfg.sec_use_y_offset
		local ydiff = syoff - pyoff
		args.yoffset = args.yoffset - ydiff + fontscale_h(ydiff)
	end
	if args.iedmode then
		args.iedtext = args.text
		args.text = args.iedtext .. " " .. args.iedmode
	end
	args.act    = args.act or ""
	args.name   = args.name or ""
	args.fixed  = ((args.fixed ~= nil) and args.fixed) or cfg.fixed_screen_pos
	if args.bind_icon then
		args.style 		= nil
	else
		args.style 		= args.style or cfg.keybind_bg_style or 0
	end
	self.args   = args
end

function InteractPrompt:SetupButtonHandlers()
	vl("[%s] InteractPrompt:SetupButtonHandlers | scheme: %s", self.args.section, self.args.scheme)
	local method = "on_use"
	if (self.args.scheme == "ph_button") then
		method = "on_press"
	elseif (self.args.scheme == "ph_code") then
		method = "on_code"
	end
	self.physbtn_active = (
		function()
			local btn = self.args.id and self.args.scheme and db.storage[self.args.id] and db.storage[self.args.id][self.args.scheme]
			return btn and method and not not btn[method]
		end
	)
end

--- @param filters table
function InteractPrompt:SetupHintFilters(filters)
	filters = filters or self.args.hint_filters
	self.args.hint_filters = self.args.hint_filters or {}
	if (not filters) or (is_empty(filters)) then return end
	function add_hint_filter(m, r)
		hintfilters.add(m, r)
		self.args.hint_filters[m] = r
		self.filters[m] = function() return hintfilters.get_state(m) end
		self.prompts[m] = function() return self.filters[m]() and hintfilters.get_text(m) or nil end
	end

	self.filters = {}
	self.prompts = {}
	for k,v in pairs(filters) do
		add_hint_filter(k, v)
	end
	self.args.hint_filters = filters
	RegisterScriptCallback("on_quickhelp_text_update", self)
end

function InteractPrompt:GetMark()
	if self.args.mark_id then
		return hmm:GetMarker(self.args.mark_id)
	elseif (self.id or self.args.id) and cfg.markers[(self.id or self.args.id)] then
		return cfg.markers[self.args.id]
	end
end

--- @param weight number
function InteractPrompt:GetInvWeightDisplay(weight)
	local wc = weight and get_actor_weight_class(weight)
	local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
	self.parse_text_colors = true
	return string.format(" ($%s%.2f %s$clr_def)", code, self.weight, st_kg)
end

function InteractPrompt:SetupDoorHandlers()
	vl("Setting up door handler object and methods")
	local args = self.args
	local ph_door = args.id and db.storage[args.id] and db.storage[args.id]["ph_door"]

	self.door = {
		data = ph_door,
		ctrl = ph_door.door_action
	}
	local door = self.door
	if not door.ctrl then return end

	door.lo, door.hi = door.ctrl.joint:get_limits(0, 0, 0)
	door.mid = (door.lo + door.hi) * 0.5
	door.deadzone = 0.1
	door.is_open = (
		function()
			return self.door.ctrl and self.door.ctrl.is_open and self.door.ctrl:is_open()
		end
	)
	door.tips = {
		close   = self.door.data and self.door.data.tip_close,
		open    = self.door.data and self.door.data.tip_open,
		unlock  = self.door.data and self.door.data.tip_unlock,
	}
	door.joint_pos = (
		function()
			return self.door.ctrl and
				self.door.ctrl.joint and
				self.door.ctrl.joint.get_axis_angle and
				self.door.ctrl.joint:get_axis_angle(0)
		end
	)
	door.tip = (
		function()
			local locked = self.door.data and self.door.data.locked
			local tips = self.door.tips
			local msg = locked and tips.unlock or self.door.is_open() and tips.close or tips.open
			return msg
		end
	)
	args.text = gts(self.door.tip())
	self.args.hint_filters = {}
	for k,v in pairs(door.tips) do self.args.hint_filters[v] = v end
end


function InteractPrompt:GetWndOffset()
	if self.args.locked_screen_pos then
		return self.args.locked_screen_pos.x, self.args.locked_screen_pos.y
	else
		return self.args.xoffset, self.args.yoffset
	end
end

function InteractPrompt:GetPosOffsets()
	local xoff, yoff = 0, 0
	if not self.args.locked_screen_pos then
		xoff, yoff = self:GetWndOffset()
	end
	return xoff, yoff
end

--- @param x number
--- @param y number
function InteractPrompt:SetLinePos(x, y)
	local xoff, yoff 	= self:GetPosOffsets()

	setwndpos(self.line,
		(x or 0) + 15 	+ (self.args.line_adj_x or 0),
		(y or 0) + -15	+ (self.args.line_adj_y or 0)
	)
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param x number
--- @param y number
function InteractPrompt:GetMainWndPos(mark, x, y)
	mark 			= mark or self.linked_mark or self:GetMark() or {}
	if self.linked_mark then

	end
	local arg_tbl 	= mark.is_active and mark.task_swap or mark.active_swap or mark.args or {}
	local adj_w 	= ((mark and mark.width or 6) - (arg_tbl.width or 6)) * 0.5
	local adj_h 	= ((mark and mark.height or 6) - (arg_tbl.height or 6)) * 0.5
	local new_x 	= (x or 0) + self.args.xoffset + adj_w
	local new_y		= (y or 0) + self.args.yoffset + adj_h
	--dump("x %s + xoff %s + adj_w %s: %s | y %s + yoff %s + adj_h %s: %s", x, self.args.xoffset, adj_w, new_x, y, self.args.yoffset, adj_h, new_y)
	return new_x, new_y
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param x number
--- @param y number
function InteractPrompt:UpdateMainWndPos(mark, x, y)
	if self.args.locked_screen_pos then return end
	x, y 			= self:GetMainWndPos(mark, x, y)
	setwndpos(self.wnd, x, y)
end


function InteractPrompt:SetupConnectingLine()
	-- White line - really cheap trick but looks nice in certain positions
	if not self.line then
		self.line = self.xml:InitProgressBar("prog_dotpointer", self.wnd)
	end

	if self.args.pri then
		self:SetLinePos(
			(self.args.line_adj_x or 0) + -3.5,
			(self.args.line_adj_y or 0) + 3
		)
		setwndsize(self.line, 5 + (self.args.line_adj_w or 0), 26 + (self.args.line_adj_h or 0))
	else
		self.line:Show(false)
	end
end


function InteractPrompt:BuildUI()
	vl("InteractPrompt:BuildUI | %s", self.args.name or self.args.text or self.args.tutorial or self.args.event)
	if self.wnd then
		for k,_ in pairs(self.elements) do
			self[k] = nil
		end
	end

	local xml           = self.xml
	xml:ParseFile(cfg.interact_uifile)
	local args          = self.args
	local boxlen        = fontscale_w(#args.bind * cfg.bind_char_scale)
	local boxpos        = -(boxlen - 4)
	local stretch_adj   = 0

	self.wnd            = xml:InitStatic("alt_interact", self.anchor)
	self.drop           = xml:InitStatic("box", self.wnd)
	setwndpos(self.drop,
		-boxlen + fontscale_w(cfg.interact_drop_x),
		fontscale_h(cfg.interact_drop_y)
	)
	self.drop:InitTexture(cfg.main_drop_texture)
	self:eleSetBaseColorScheme(self.drop, clr_tbl(clamp(tonumber(cfg.interact_drop_alpha) * 255, 0, 255), 255, 255, 255))
	self:SetupConnectingLine()

	local one_char = args.bind and (#args.bind == 1)

	if self.args.style then
		self.dark_text  = (self.args.style > 1)
	end

	if cfg.hide_keybind_element then
		self.prompt     = xml:InitStatic("box", self.wnd)
		self.prompt:Show(false)
		self.args.bind 	= ""
	else
		if self.args.bind_icon then
			self.prompt     = xml:InitStatic("alt_interact:prompt", self.wnd)
			self.prompt:InitTexture(self.args.bind_icon)
			if self.args.bind_icon_w or self.args.bind_icon_h then
				setwndsize(self.prompt, self.args.bind_icon_w or 0, self.args.bind_icon_h or 0)
			end
			if self.args.bind_icon_x or self.args.bind_icon_y then
				setwndpos(self.prompt, self.args.bind_icon_x or 0, self.args.bind_icon_y or 0)
			end
			self.args.bind = ""
		else
			if one_char then
				self.prompt     = xml:InitStatic("alt_interact:prompt", self.wnd)
				self.prompt:InitTexture("ui_catsy_keybind_bg_single_v" .. self.args.style)
				setwndsize(self.prompt, fontscale_w(15), fontscale_h(20))
			else
				self.prompt     = xml:InitStatic("box", self.wnd)
				
				self.prompt_l   = xml:InitStatic("alt_interact:prompt_l", self.prompt)
				self.prompt_c   = xml:InitStatic("alt_interact:prompt_c", self.prompt)
				self.prompt_r   = xml:InitStatic("alt_interact:prompt_r", self.prompt)
				self.prompt_l:InitTexture("ui_catsy_keybind_bg_left_v" .. args.style)
				self.prompt_c:InitTexture("ui_catsy_keybind_bg_center_v" .. args.style)
				self.prompt_r:InitTexture("ui_catsy_keybind_bg_right_v" .. args.style)

				stretch_adj     = 2
				setwndsize(self.prompt_l, fontscale_w(5.3125), fontscale_h(20))
				setwndpos(self.prompt_l, 0, 0)
				setwndsize(self.prompt_c, boxlen, fontscale_h(20))
				setwndpos(self.prompt_c, fontscale_w(5.1125), 0)
				setwndpos(self.prompt_r, fontscale_w(4.78) + boxlen, 0)
				setwndsize(self.prompt_r, fontscale_w(5.3125), fontscale_h(20))
			end
			setwndpos(self.prompt, boxpos or 0, 0)
		end
	end

	-- Set up long press progress indicator
	if args.long then
		self.longpress  = xml:InitProgressBar("prog_longpress", self.prompt)
		self.longpress:SetColor(getargb(self.progress_color))
		self.longpress:SetProgressPos(0)
		--setwndsize(self.longpress, fontscale_w(15), fontscale_h(20))
		-- resizing disabled until it can be done right
	end

	-- Set up text drop shadows
	self.bind_sh        = xml:InitStatic("alt_interact:label", self.prompt)
	self.label_sh       = xml:InitStatic("alt_interact:label", self.wnd)
	setwndsize(self.bind_sh, (boxlen or 0) + fontscale_w(15), fontscale_h(20))
	setwndpos(self.bind_sh,
		get_font_xoff() + fontscale_w(stretch_adj + cfg.bind_text_pos_x + 1.5),
		fontscale_h(cfg.bind_text_pos_y - 0.25)
	)
	setwndpos(self.label_sh, 
		get_font_xoff() + fontscale_w(cfg.action_text_pos_x + 0.5),
		fontscale_h(cfg.action_text_pos_y + 0.5)
	)
	self.bind_sh:TextControl():SetFont(get_font_obj())
	self.label_sh:TextControl():SetFont(get_font_obj())

	-- Keybind text indicator
	self.bind           = xml:InitStatic("alt_interact:label", self.prompt)
	self:eleSetBaseColorScheme(self.bind, self.dark_text and self.text_color_dark or self.text_color_light)
	self.bind:TextControl():SetFont(get_font_obj())

	self:SetBindText(bindtext(self:BindKey(), self:ModKey()))

	setwndsize(self.bind, (boxlen or 0) + fontscale_w(15), fontscale_h(20))
	setwndpos(self.bind,
		get_font_xoff() + fontscale_w(stretch_adj + cfg.bind_text_pos_x + (one_char and 1.5 or 0)),
		fontscale_h(cfg.bind_text_pos_y)
	)

	-- Width reference static
	self.lref      = xml:InitStatic("box", self.wnd)
	self.lref:Show(false)

	-- Prompt text label
	self.label          = xml:InitStatic("alt_interact:label", self.wnd)
	self:eleSetBaseColorScheme(self.label, self.text_color_light)
	setwndpos(self.label, get_font_xoff() + fontscale_w(cfg.action_text_pos_x), fontscale_h(cfg.action_text_pos_y))
	self.label:TextControl():SetFont(get_font_obj())

	self:eleSetBaseColorScheme(self.bind_sh, self.text_color_dark)
	if self.dark_text then
		self.bind_sh:Show(false)
	end
	self:eleSetBaseColorScheme(self.label_sh, self.text_color_dark)

	local obj = self.args.id and get_game_object(self.args.id)
	self:SetupSuffix(obj)
	self:SetPrompt()

	if obj and self.args.pri then
		self:SetupItemCard(self.wnd, obj)
		self:SetupUtjanPartDots(self.itemcard)
	end

	if self.args.locked_screen_pos then
		self.wnd:SetWndPos(self.args.locked_screen_pos)
	else
		self:UpdateMainWndPos()
	end

	vl("Completed %sbuilding interact UI: %s", self.init_done and "re" or "", self.active_prompt)
	self.init_done = self.init_done or time_global()
	self:actor_on_update()
end

--- @param obj game_object
function InteractPrompt:SetupSuffix(obj)
	obj             = obj or (self.args.id and get_game_object(self.args.id))
	if (not obj) then return end
	local sec       = self.args.section or obj:section()
	if self.args.is_readable then
		self.unread = not is_recipe_known(sec)
		self.active_suffix = " "..gts("st_dotmarks_note_read_"..(self.unread and "no" or "yes"))
		return
	elseif not (cfg.show_item_condition or cfg.show_item_charge) then
		--self.active_suffix = ""
		return
	end

	
	local cls       = self.args.clsid or obj:clsid()
	local has_cond  = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
	local is_mag    = magazine_binder and sec and magazine_binder.is_magazine(sec)
	local wpn_cnd 	= (self.args.is_weapon and cfg.show_gun_condition)
	local gear_cnd  = (self.args.has_parts and cfg.show_item_condition) and not self.args.is_weapon
	local part_cnd 	= (self.args.is_part_cnd and cfg.show_item_condition and cfg.parts_have_condition)
	local batt_cnd  = ((self.args.has_power or self.args.has_battery) and cfg.show_item_charge)
	if self.args.multi_uses then
		-- Setup suffix text for multiuse items
		if cfg.show_multi_uses and (self.args.multi_uses > 1) then
			self.active_suffix = string.format(" (%s %s)", self.args.multi_uses, gts("st_alti_uses"))
		else
			self.active_suffix = ""
		end
	elseif has_cond and (wpn_cnd or gear_cnd or batt_cnd or part_cnd) and (not is_mag) then
		-- Setup suffix text for degradable items
		local cond = obj and obj:condition()
		vl("%s show_condition | wpn %s | gear %s | batt %s | part %s", self.args.name, wpn_cnd, gear_cnd, batt_cnd, part_cnd)
		self.show_condition = true
		self:SetConditionText(sec, cond)
	else
		self.active_suffix = ""
	end
end


--- @param sec string
--- @param cond number
function InteractPrompt:SetConditionText(sec, cond)
	 if (cond and sec) then
		cond = math.floor(cond * 100)
	 	if (cond == self.last_cond_text) then return end
	 	self.last_cond_text = cond
		local c = get_condition_color(cond, sec)
		local key = "clr_" .. cond .. (self.args.has_power and "_batt" or "_cond")
		local str   = c and string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
		if str then set_color_token(key, str) end
		self.parse_text_colors = true
		if (cond < 0.01) and self.args.has_power then
			self.active_suffix = string.format(" ($%s%s$clr_def)", key, gts("st_alti_nopower"))
		else
			self.active_suffix = string.format(" ($%s%s%%$clr_def)", key, cond)
		end
		self:UpdatePromptLength()
	else
		self.active_suffix = ""
	end
end

function InteractPrompt:UpdatePromptLength()
	local len           = self.prompt_length
	self.prompt_length  = self.lref:GetWidth() + 25
	if len == self.prompt_length then return self.prompt_length end
	if self.itemcard then
		local o 	= fontscale_w(self.prompt_length)
		local x 	= (cfg.item_card_pos_x + o + (self.dots_x or 0))
		local y 	= (cfg.item_card_pos_y or 0)
		setwndpos(self.itemcard, x, y)
	end
	--dump("Prompt length for %s: %s", self.lref:TextControl():GetText(), self.prompt_length)
	return self.prompt_length
end

function InteractPrompt:UpdateWeightColor()
	if not (self.card_wgt_icon and self.card_wgt_text) then return end
	local c = get_state_color(self.weight, 3)
	local color = c and getargb(c)
	if not color then return end
	self.card_wgt_icon:SetTextureColor(color)
	self.card_wgt_text:TextControl():SetTextColor(color)
end

--- @param anchor CUIStatic
--- @param obj game_object
function InteractPrompt:SetupItemCard(anchor, obj)
	if (not cfg.show_item_card) or (not self.args.is_pickup) then return end
	if self.itemcard then self.itemcard:Show(false) end
	obj = obj or (self.args.id and get_game_object(self.args.id))
	sec = self.args.inv_section or (obj and obj:section())
	if not sec then return end

	self.weight     = dec2(ini_sys:r_float_ex(sec,"inv_weight") or 0)
	local value     = dec2(ini_sys:r_float_ex(sec,"cost") or 0)

	xml:ParseFile(cfg.interact_uifile)
	local offset    = fontscale_w(self:UpdatePromptLength())
	self.itemcard   = self.xml:InitStatic("box", anchor or self.wnd)
	local show_dots = can_show_part_dots(self.args.id)
	local icon_sz   = cfg.item_card_icon_sz
	self.dots_x 	= show_dots and (10 * cfg.unsquish_ratio) or 0
	local wnd_x     = cfg.item_card_pos_x + self.dots_x
	local wnd_y     = cfg.item_card_pos_y
	local text_y    = cfg.item_card_text_y
	local elem_x    = cfg.item_card_elem_x
	local elem_y    = cfg.item_card_elem_y
	local elem_h    = fontscale_w(cfg.item_card_elem_h)
	local icon_x    = cfg.item_card_icon_x
	local icon_y    = cfg.item_card_icon_y

	setwndpos(self.itemcard, wnd_x + offset, wnd_y)
	--dump("Initting item card position as %s, %s", wnd_x + offset, wnd_y)
	local card_font = get_font_obj(cfg.font_item_card or 0)
	self.card_wgt = self.xml:InitStatic("box", self.itemcard)
	setwndpos(self.card_wgt, elem_x, elem_y)
	self.card_wgt_icon = self.xml:InitStatic("box", self.card_wgt)
	setwndsize(self.card_wgt_icon, icon_sz * cfg.unsquish_ratio, icon_sz)
	setwndpos(self.card_wgt_icon, icon_x, icon_y)
	self.card_wgt_icon:InitTexture(cfg.item_card_icon_weight)
	self.card_wgt_icon:Show(true)

	offset = elem_x + self.card_wgt_icon:GetWidth()
	self.card_wgt_sh 	= self.xml:InitStatic("box", self.card_wgt)
	self.card_wgt_text 	= self.xml:InitStatic("box", self.card_wgt)
	setwndsize(self.card_wgt_sh, 0, elem_h)
	setwndpos(self.card_wgt_sh, offset + (0.5 * cfg.unsquish_ratio), text_y + 0.5)
	setwndsize(self.card_wgt_text, 0, elem_h)
	setwndpos(self.card_wgt_text, offset, text_y)
	self.card_wgt_sh:TextControl():SetFont(card_font)
	self.card_wgt_sh:TextControl():SetText(self.weight)
	self.card_wgt_sh:AdjustWidthToText()
	self:eleSetBaseColorScheme(self.card_wgt_sh, self.text_color_dark)
	self.card_wgt_text:TextControl():SetFont(card_font)
	self.card_wgt_text:TextControl():SetText(self.weight)
	self.card_wgt_text:AdjustWidthToText()
	self.card_wgt_text:Show(true)
	self:UpdateWeightColor()

	local weight_w = offset + self.card_wgt_text:GetWidth()
	setwndsize(self.card_wgt, weight_w + 6, elem_h)
	local c = dup_table(cfg.colors.clr_card_drop)
	c.a 	= clamp(tonumber(cfg.interact_drop_alpha) * tonumber(c.a), 0, 255)
	self.card_wgt:InitTexture("ui_dotmarks_main_drop")
	self.card_wgt:SetTextureColor(getargb( c ))

	offset = elem_x
	self.card_val = self.xml:InitStatic("box", self.itemcard)
	setwndpos(self.card_val, offset, elem_y + elem_h + cfg.item_card_elem_spacing)
	self.card_val_icon = self.xml:InitStatic("box", self.card_val)
	setwndsize(self.card_val_icon, icon_sz * cfg.unsquish_ratio, icon_sz)
	setwndpos(self.card_val_icon, icon_x, icon_y)
	self.card_val_icon:InitTexture(cfg.item_card_icon_value)
	self.card_val_icon:SetTextureColor(getargb( cfg.colors.clr_text_light ))
	self.card_val_icon:Show(true)

	offset = elem_x + self.card_val_icon:GetWidth()
	self.card_val_sh 	= self.xml:InitStatic("box", self.card_val)
	self.card_val_text 	= self.xml:InitStatic("box", self.card_val)
	setwndsize(self.card_val_sh, 0, elem_h)
	setwndpos(self.card_val_sh, offset + (0.5 * cfg.unsquish_ratio), text_y + 0.5)
	setwndsize(self.card_val_text, 0, elem_h)
	setwndpos(self.card_val_text, offset, text_y)
	self.card_val_sh:TextControl():SetFont(card_font)
	self.card_val_sh:TextControl():SetText(value)
	self.card_val_sh:AdjustWidthToText()
	self:eleSetBaseColorScheme(self.card_val_sh, self.text_color_dark)
	self.card_val_text:TextControl():SetFont(card_font)
	self.card_val_text:TextControl():SetText(value)
	self.card_val_text:TextControl():SetTextColor(getargb( cfg.colors.clr_text_light )) 
	self.card_val_text:AdjustWidthToText()
	self.card_val_text:Show(true)

	local value_w = offset + self.card_val_text:GetWidth()
	setwndsize(self.card_val, value_w + 6, elem_h)
	self.card_val:InitTexture("ui_dotmarks_main_drop")
	self.card_val:SetTextureColor(getargb( c ))
	
	self.card_sp_icon = self.xml:InitStatic("box", self.itemcard)
	self.longest_card = math.max(weight_w, value_w)

	self:UpdateFaveJunkIcon()
	self.itemcard:Show(true)
end

function InteractPrompt:UpdateFaveJunkIcon()
	if not (zzz_rax_sortingplus_mcm and cfg.sp_flag_favejunk) then return end
	if not self.card_sp_icon then return end

	local texture = (is_favorite(self.args.section) and cfg.icon_sp_fave_texture) or
					(is_junk(self.args.section) and cfg.icon_sp_junk_texture) or
					""
	self.card_sp_icon:InitTexture(texture)
	local has_icon = (texture ~= "")
	self.card_sp_icon:Show(has_icon)
	if not has_icon then return end

	setwndpos(self.card_sp_icon,
		self.longest_card + fontscale_w(cfg.sp_icon_pos_x or 0),
		(cfg.sp_icon_pos_y or 0)
	)
	setwndsize(self.card_sp_icon, 16 * cfg.unsquish_ratio, 16)
end

--- @param anchor CUIStatic
--- @param obj game_object
function InteractPrompt:SetupUtjanPartDots(anchor, obj)
	if not (z_item_icon_info and item_icon_info_mcm) then return end
	obj = obj or (self.args.id and get_game_object(self.args.id))
	vl("[%s][%s] Checking whether to add part dots indicator to %s", time_global(), obj and obj:name())
	if not (obj and has_parts(obj)) then
		vl("%s does not have parts, skipping", obj and obj:name())
		return
	end
	-- Adapted from z_item_icon_info in Utjan's Item UI
	if not cfg.show_part_condition then
		vl("cfg.show_part_condition is false, skipping")
		return
	end
	if self.parts_indicators then
		vl("Hiding existing indicator")
		for k,v in pairs(self.parts_indicators) do
			self.parts_indicators[k]:Show(false)
		end
	end

	sec = obj and obj:section()
	cls = obj and obj:clsid()
	if not (sec and cls) then
		alert("Invalid object! Skipping setup, but something is very wrong")
		return
	elseif (not cfg.show_parts_weapons) and IsWeapon(nil, cls) then
		vl("Weapon part dots disabled, skipping")
		return
	elseif (not cfg.show_parts_armor) and (IsHeadgear(nil, cls) or IsOutfit(nil, cls)) then
		vl("Armor part dots disabled, skipping")
		return
	end

	local se_parts = item_parts.get_parts_con(obj, nil, true)
	if is_empty(se_parts) then
		vl("Empty se_parts for %s, skipping", obj)
		return
	end
	vl("All checks passed, setting up part dots indicator")
	local parts 	= dup_table(se_parts)
	local sep 		= cfg.parts_dot_sep_width or 1
	local base_x 	= (cfg.parts_dot_pos_x or 0)
	local base_y 	= (cfg.parts_dot_pos_y or 0)
	self.parts_container = self.xml:InitStatic("box", anchor or self.wnd)
	self.parts_indicators = self.parts_indicators or {}
	self.parts_shadows = self.parts_shadows or {}

	self.xml:ParseFile("ui_utjan_icon_info.xml")

	local drop_rad 		= cfg.parts_dot_shadow_radius or 0.5
	local dot_scale 	= cfg.parts_dot_scale or 1
	local cond_dot_h 	= dot_scale * 5
	local cond_dot_w 	= cond_dot_h * cfg.unsquish_ratio
	local shadow_sz 	= cond_dot_h + (drop_rad * 2)
	local shadow_a 		= clamp((tonumber(cfg.parts_dot_shadow_alpha) or 0) * 255, 0, 255)

	for part, v in pairs(parts) do
		if SYS_GetParam(1, part, "cond_part") then
			if not self.parts_indicators[part] then
				self.parts_shadows[part]	= self.xml:InitStatic("cond_dot", self.parts_container)
				self.parts_indicators[part] = self.xml:InitStatic("cond_dot", self.parts_shadows[part])
				setwndsize(self.parts_shadows[part], shadow_sz * cfg.unsquish_ratio, shadow_sz)
				self.parts_shadows[part]:SetTextureColor(get_argb(shadow_a, 0, 0, 0))
				setwndsize(self.parts_indicators[part], cond_dot_w, cond_dot_h)
				setwndpos(self.parts_indicators[part], drop_rad * cfg.unsquish_ratio, drop_rad)
			end
		else
			parts[part] = nil
		end
	end

	local i = 0
	local size = 0
	local centering = 2.5 * (cond_dot_h + sep)
	local elems = 5
	local pnum = size_table(parts)
	local radius = 4 - ((elems - pnum) * 0.5)
	local tau = (2 * math.pi)
	local mode = cfg.parts_dot_orientation or 0

	for part, condition in spairs(parts, z_item_icon_info.parts_sort) do
		local x, y
		if (mode > 1) then
			size = 3
			local ang = ((i / pnum) * tau) + math.pi
			x = math.sin(ang) * cfg.unsquish_ratio
			y = math.cos(ang)
			self.parts_shadows[part]:SetWndPos(vector():set(x, y, 0):mul(radius))
		else
			if (mode > 0) then
				x = 0
				y = 1 + ((cond_dot_h + sep) * i)
				size = y + cond_dot_h + sep
			else
				x = 1 + ((cond_dot_w + sep) * i)
				y = 0
				size = x + cond_dot_w + sep
			end		
			setwndpos(self.parts_shadows[part], x, y)
		end

		local c = get_condition_color(condition)
		local color = get_argb(c.a, c.r, c.g, c.b)

		if color then
			self.parts_indicators[part]:SetTextureColor( color )
		end
		self.parts_shadows[part]:Show(true)
		self.parts_indicators[part]:Show(true)
		i = i + 1
	end
	
	if (mode < 2) and cfg.parts_dot_centering and (i < 5) then
		local diff = 5 - i
		centering = centering - (diff * (cond_dot_h + sep) * 0.5)
		if (mode > 0) then
			base_y = base_y + centering
		else
			base_x = base_x + centering
		end
	end
	setwndpos(self.parts_container, base_x, base_y)
	setwndsize(self.parts_container, size, 0)
	self.parts_container:InitTexture(cfg.main_drop_texture)
	dl("Completed part dots indicator setup for %s", nameid(obj))
end

--- @param element CUIStatic
--- @param a number
--- @param r number
--- @param g number
--- @param b number
function InteractPrompt:eleSetCurrentColor(element, a, r, g, b)
	if not element then return end
	local argb = get_argb(a, r, g, b)
	if element.SetTextureColor  then element:SetTextureColor(argb) end
	if element.TextControl      then element:TextControl():SetTextColor(argb) end
	element.currcolor = {
		a = tonumber(a) or 255,
		r = tonumber(r) or 255,
		g = tonumber(g) or 255,
		b = tonumber(b) or 255
	}
end

--- @param element CUIStatic
--- @param c table
function InteractPrompt:eleSetCurrentColorScheme(element, c)
	c = c or element.basecolor or self.text_color_default
	self:eleSetCurrentColor(element, c.a, c.r, c.g, c.b)
end

--- @param element CUIStatic
--- @param c table
function InteractPrompt:eleSetBaseColorScheme(element, c)
	element.basecolor = c or self.text_color_default
	self:eleSetCurrentColorScheme(element, c)
end

--- @param clr_tbl table
function InteractPrompt:GetARGB(clr_tbl)
	return clr_tbl and get_argb({
		a = clr_tbl.a,
		r = clr_tbl.r,
		g = clr_tbl.g,
		b = clr_tbl.b
	})
end

--- @param text string
function InteractPrompt:Event(text)
	if text and self.args then self.args.event = text end
	return text or (self.args and self.args.event) or "sec_interact"
end

--- @param text string
function InteractPrompt:BindKey(text)
	if text and self.args then self.args.key = text end
	return text or (self.args and self.args.key) or cfg["bind_" .. self:Event()] or 0
end

--- @param text string
function InteractPrompt:ModKey(text)
	if text and self.args then self.args.mod = text end
	return text or (self.args and self.args.mod) or cfg["modk_" .. self:Event()] or 0
end

--- @param text string
function InteractPrompt:InputMode(text)
	if text and self.args then self.args.imod = text end
	return text or (self.args and self.args.imod) or 0 
end

--- @param text string
function InteractPrompt:SetBindText(text)
	text = text or (self.args and self.args.bind) or ""
	self.bind:TextControl():SetText(text)
	self.bind_sh:TextControl():SetText(text)
end

--- @param key number
function InteractPrompt:on_key_hold(key)
	if input_killswitch() then return end
	--dump("[%s] InteractPrompt:on_key_hold | key %s", key)
	if (self.disabled or self.destroyed or self.busystate) then return end
	
	if (key == self.args.key) and (self.args.mode == 2) and ui_mcm.get_mod_key(self.args.mod) then
		local now = time_global()
		if ui_mcm.key_hold(self.uid, key, 5) then
			local tid = get_current_target()
			cfg.last_hold   = {
				key         = cfg.held_key,
				time        = now,
				by          = self
			}
			self.peak_hold  = nil
			cfg.held_key    = nil
			cfg.held_mod    = nil
			cfg.held_time   = nil
			cfg.holding     = nil
			cfg.use_released= cfg.use_released or now
			--dump("[%s][InteractPrompt:on_key_hold] Setting cfg.use_released to %s", now, cfg.use_released)
			self.longpress:SetProgressPos(0)
			self:ExecuteAction(tid)
			return
		elseif cfg.last_hold and (cfg.last_hold.key == self.args.key) and not timed_out(cfg.last_hold.time, cfg.long_press_delay or 50) then
			--dump("[%s][InteractPrompt:on_key_hold] Tried to start another hold too soon, aborting", now)
			self.longpress:SetProgressPos(0)
			return
		end

		if not cfg.held_key then
			self.longpress:SetProgressPos(0)
			dump("[%s][InteractPrompt:on_key_hold] Beginning hold of key %s", now, self.args.key)
		end
		cfg.held_key    = key
		cfg.holding     = self
		cfg.held_mod    = self.args.mod
		cfg.held_time   = ui_mcm and ui_mcm.hold[key] and ui_mcm.hold[key][self.uid]
	end
end

function InteractPrompt:ModKeyHeld()
	if not is_modkey_ignored(self:ModKey()) then return false end
   	return ui_mcm and ui_mcm.get_mod_key(self:ModKey())
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function InteractPrompt:ExecuteAction(id, mark)
	mark = mark or self:GetMark()
	local flags = {ret_value = true}
	if not self.args.pri then
		dump("Sending callback dotmarks_on_before_marker_init for %s", nameid(get_mark_name(id), id))
		SendScriptCallback("dotmarks_on_before_secondary_action", id, mark, self, self.args.func, flags)
	end
	if flags and flags.ret_value then
		vl("[%s][InteractPrompt:ExecuteAction] Triggering action %s for %s", time_global(), self:Event(), self.args.name)
		self.args.func(id or self.args.id, mark)
	end
end

--- @param key number
--- @param flags table
function InteractPrompt:on_key_press(key, flags)
	if input_killswitch() then return end
	if (self.disabled or self.destroyed or self.busystate) then return end
	local mark = self:GetMark()

	if (key == self.args.key) then
		if not ui_mcm then
			self:ExecuteAction()
			return
		end

		if (self.args.mode == 0) and self:ModKeyHeld() then
			ui_mcm.simple_press(self.uid, key, self.args.func, self.args.id, mark)
		end
	
		if (self.args.mode == 1) and self:ModKeyHeld() and ui_mcm.double_tap(self.uid, key) then
			cfg.last_tap = time_global()
			self:ExecuteAction()
			return
		end
	end    
end

function InteractPrompt:actor_on_net_destroy() 
	self.disabled = true
	self.destroyed = true
	get_hud():RemoveDialogToRender(self)
end

function InteractPrompt:on_option_change()
	if self.args.tutorial and self.init_done then
		self:Destroy()
		return
	end
	if self.args.pri then
		self.args.key   = self.args.key or bind_to_dik(key_bindings.kUSE)
	else
		local sec       = cfg.bind_sec_interact
		local tap_time  = self.args.tap_time or cfg.double_tap_time
		self.hold_time  = (self.args.hold_time or (ui_mcm and ui_mcm.get("mcm/mcm_kb/mcm_kb_main/presstime")) or 2) * tap_time
		self.args.key   = cfg["bind_" .. (self.args.event or "")] or sec or 0
		self.args.mod   = cfg["modk_" .. (self.args.event or "")] or sec or 0 
		self.args.mode  = cfg["imod_" .. (self.args.event or "")] or sec or 0
	end

	self:BuildUI()

	self.bind_sh:Show((not self.dark_text) and (not cfg.hide_drop_shadow))
	self.label_sh:Show(not cfg.hide_drop_shadow)
end

--- @param tf boolean
--- @param prefix string
--- @param force_update boolean
function InteractPrompt:BusyState(tf, prefix, force_update)
	local last_state = self.busystate
	self.busystate = not not tf
	if force_update or ((tf ~= nil) and (self.busystate ~= last_state)) then
		--dump("InteractPrompt:BusyState has changed to %s, updating prompt visuals", self.busystate)
		if self.busystate then
			self.active_prefix  = (prefix or gts("st_alti_busy")) .. " "
			self.active_prompt  = first_lower(self.active_prompt)
			if self.text_color_busy then
				self:eleSetCurrentColorScheme(self.label, self.text_color_busy)
				self:eleSetCurrentColorScheme(self.bind, self.text_color_busy)
			end
		else
			self.active_prefix = self.args.act
			self:eleSetCurrentColorScheme(self.label, self.text_color_light)
			self:eleSetCurrentColorScheme(self.bind, self.dark_text and self.text_color_dark or self.text_color_light)
			self.active_prompt  = first_upper(self.active_prompt)
		end
		if self.itemcard and cfg.show_item_card then
			self.itemcard:Show(not tf)
		end
		if self.parts_container and cfg.show_item_card then
			self.parts_container:Show(not tf)
		end
		self:RegisterScriptCallbacks(not self.busystate)
		self:SetPrompt()
	end
	return self.busystate
end

function InteractPrompt:AbortFadeIn() return self.fading_out or not self.fading_in end
function InteractPrompt:AbortFadeOut() return self.fading_in or not self.fading_out end

--- @param element_name string
--- @param norm_alpha number
--- @param text_also boolean
function InteractPrompt:ScaleAlpha(element_name, norm_alpha, text_also)
	--dump("Scaling alpha for element %s: %s -> %s", element_name, norm_alpha, (norm_alpha or 0) * 255)
	local ele = element_name and self[element_name]
	norm_alpha = norm_alpha or 1
	if ele then
		local base_a = clamp(tonumber(ele.basecolor and ele.basecolor.a) or 255, 0, 255)
		local alpha = (base_a * norm_alpha)
		local c = {}
		if ele.GetTextureColor then
			local i = ele:GetTextureColor()
			c.r,c.g,c.b,c.a = i and int_to_rgba(i)
			c.a = alpha or c.a
			ele:SetTextureColor(get_argb(c.a,c.r,c.g,c.b))
		end
		if text_also then
			c = ele.currcolor or ele.basecolor or {}
			c.a = alpha or c.a
			c.r = c.r or 255
			c.g = c.g or 255
			c.b = c.b or 255
			ele.currcolor = c
			ele:TextControl():SetTextColor(get_argb(c.a,c.r,c.g,c.b))
		end
	end
end

--- @param alpha_start number
--- @param alpha_end number
--- @param duration number
--- @param event_id string
--- @param instanced boolean
--- @param r number
--- @param g number
--- @param b number
--- @param anim_curve_modifier_func function
--- @param on_finish_func function
--- @param abort_func function
function InteractPrompt:ManageFadeAnim(alpha_start, alpha_end, duration, event_id, instanced, r, g, b, anim_curve_modifier_func, on_finish_func, abort_func)

	local fade_dir = (alpha_start > alpha_end) and "out" or "in"
	if (event_id == nil) then event_id = "anim_fade" end
	local anim_id = event_id.."_"..tostring(time_global())
	r = r or 255
	g = g or 255
	b = b or 255

	local start_time= time_global()
	local end_time  = time_global() + duration
	local mark 		= self:GetMark()
	local mark_id 	= mark and mark.mark_id or ""
	if not active_anims[mark_id] then 
		active_anims[mark_id] = {}
	end

	--dump("[%s] [fading: %s] AnimateFade passed initial checks, time to fade %s", time_global(), self.fading_out, fade_dir)

	if active_anims[mark_id][event_id] then
		--dump("[%s] Existing animation found for %s::%s, updating", time_global(), mark_id, event_id)
		local anim 		= active_anims[mark_id][event_id]
		anim.start_time = start_time
		anim.end_time 	= end_time
		anim.a_start 	= anim.a
		anim.a_end 		= alpha_end
		anim.r 			= r
		anim.g 			= g
		anim.b 			= b
		return
	end

	local anim_state = 0
	local anim_curve_modifier_func = anim_curve_modifier_func or function(x) return x end
	active_anims[mark_id][event_id] = {
		anim_id     = anim_id,
		start_time  = start_time,
		end_time    = end_time,
		active      = true,
		a_start     = alpha_start,
		a_end       = alpha_end,
		a           = alpha_start,
		r           = r,
		g           = g,
		b           = b,
	}

	CreateTimeEvent("animate_fade"..event_id..anim_id, time_global(), 0, 
		function()
			local abort = (not active_anims[mark_id]) or (abort_func and abort_func(self))
			if abort then
				anim_state = 1
			else
				local anim = active_anims[mark_id][event_id]
				if anim then
					local x = anim_curve_modifier_func(anim_state)
					local alpha = lerp(alpha_start, alpha_end, x)
					anim.a = alpha
					self.curr_alpha = alpha
					x = (alpha / 255)
					--dump("[%s] anim_state %s | start %s | end %s | setting alpha to %s", time_global(), anim_state, alpha_start, alpha_end, alpha)
					for k,v in pairs(self.elements) do
						self:ScaleAlpha(k, x, v)
					end
				else
					anim_state = 1
				end
			end

			if (anim_state == 1) then
				if active_anims[mark_id] then
					active_anims[mark_id][event_id] = nil
				end
				self.fading_in = false
				self.fading_out = false
				--dump("[%s] anim complete", time_global())
				if on_finish_func then on_finish_func(self) end
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

--- @param inout boolean
function InteractPrompt:AnimateFade(inout)
	--dump("AnimateFade(%s) start | curr alpha: %s", inout, self.curr_alpha)
	if inout and self.fading_in then return end
	if (not inout) and self.fading_out then return end

	local uid = "prompt_fade" .. self.args.event
	if not self.curr_alpha then
		--dump("No current alpha, initializing for first time at 0")
		self.curr_alpha = 0
	end
	if inout then
		if self.fading_out then
			self.fading_out = false
		end
		if (self.curr_alpha ~= 255) and (cfg.prompt_fade_in_time and (cfg.prompt_fade_in_time > 0)) then
			self.fading_in = true
			--dump("[%s] triggering fade-in anim (curr alpha: %s)", time_global(), self.curr_alpha)
			self:ManageFadeAnim(
				self.curr_alpha, 255, cfg.prompt_fade_in_time, uid .. "in", false, nil, nil, nil, 
				nil,
				nil, self.AbortFadeIn
			)
		end
	else
		if self.fading_in then
			--dump("fade-in cancel, setting self.fading_in = false")
			self.fading_in = false
		end
		if (self.curr_alpha ~= 0) and (cfg.prompt_fade_out_time and (cfg.prompt_fade_out_time > 0)) then
			self.fading_out = true
			--dump("[%s] triggering fade-out anim (curr alpha: %s)", time_global(), self.curr_alpha)
			self:ManageFadeAnim(
				self.curr_alpha, 0, cfg.prompt_fade_out_time, uid .. "out", false, nil, nil, nil, 
				nil,
				self.UpdatePromptVisibility, self.AbortFadeOut
			)
		end
	end
	--dump("AnimateFade(%s) end | curr alpha: %s", inout, self.curr_alpha)
end
		
--- @param tf boolean
function InteractPrompt:UpdatePromptVisibility(tf)
	self.wnd:Show(tf)
end

--- @param tf boolean
function InteractPrompt:RegisterScriptCallbacks(tf)
	if self.callbacks_set and not tf then
		UnregisterScriptCallback("on_key_hold", self)
		UnregisterScriptCallback("on_key_press", self)
		if self.args.physics_obj or self.args.iedmode then
			UnregisterScriptCallback("on_before_key_press", self)
			if self.args.iedmode and cfg.sec_use_mousewheel_timer then
				UnregisterScriptCallback("on_mouse_wheel", self)
			end
		end
		self.callbacks_set = false
	elseif tf and not self.callbacks_set then
		RegisterScriptCallback("on_key_hold", self)
		RegisterScriptCallback("on_key_press", self)
		if self.args.physics_obj or self.args.iedmode then
			RegisterScriptCallback("on_before_key_press", self)
			if self.args.iedmode and cfg.sec_use_mousewheel_timer then
				RegisterScriptCallback("on_mouse_wheel", self)
			end
		end
		self.callbacks_set = true
	end
end

function InteractPrompt:MarkConditionsValid()
	local mark = self:GetMark()
	if self.args.mark_id and (not mark) or (mark and mark.destroying) then
		self:Destroy("parent mark missing or invalid")
		return
	end
	if self.args.func_valid then
		return self.args.func_valid(mark, self.args)
	end
	return true
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function InteractPrompt:SyncWndPos(mark)
	mark 		= mark or self.linked_mark or self:GetMark()
	if not mark then return end
	local x, y 	= self:GetMainWndPos(mark, x, y)
	local pos 	= mark.marker:GetWndPos()
	x 			= (pos and pos.x or 0) + (x or 0)
	y 			= (pos and pos.y or 0) + (y or 0)
	setwndpos(self.wnd, x, y)
end

--- @param state boolean
function InteractPrompt:UpdateMark(state)
	if not self:MarkConditionsValid() then
		self:Destroy("invalid prompt")
	end
	if not (self.linked_mark and self.linked_mark.mark_id) then return end
	if (state == nil) then state = not self.disabled end
	--dump("Propagating state %s to linked mark %s", state, self.linked_mark.name)
	update_marker_active_state(self.linked_mark, state)
	self.linked_mark:ActiveSwap(state)
	self:SyncWndPos(self.linked_mark)
	if state and can_start_popin_anim(self.linked_mark) then
		init_active_marker_popin(self.linked_mark)
	end
end

function InteractPrompt:CheckCampfireStates()
	if self.campfire_tut then
		_ = debug_dump and vl("Checking campfire state for %s", self.args.tutorial)
		local obj = get_nearby_campfire(5, false)
		if obj then
			local id = obj and obj:id()
			local mark = get_mark(id)
			if mark then
				self.linked_mark = mark
			end
			cfg.active_campfire = id
		else
			dl("Clearing stuck tutorial %s at %s", self.tutorial, time_global())
			cfg.active_campfire = nil
			self:Destroy()
		end
	elseif self.args.is_campfire then
		--

	end
end

--- @param state boolean
function InteractPrompt:UpdateDoubletapWait(state)
	if not (self.args.mode == 1) then return end
	if state then
		cfg.current_dtap = self.uid
	elseif (cfg.current_dtap == self.uid) then
		cfg.current_dtap = nil
	end
end

--- @param state boolean
--- @param reason string
function InteractPrompt:OnVisibilityChange(state, reason)
	local _ = debug_dump and vl("[%s][InteractPrompt:OnVisibilityChange] to %s%s", time_global(), state, reason)
	self:RegisterScriptCallbacks(state)
	self:CheckCampfireStates()
	self:UpdateMark(state)
	self:UpdateDoubletapWait(state)
	dump("Sending callback dotmarks_on_prompt_visibility_change for prompt %s", self.uid)
	SendScriptCallback("dotmarks_on_prompt_visibility_change", mark, self, state)
end

--- @param tf boolean
--- @param reason string
function InteractPrompt:ShowPrompt(tf, reason)
	if (tf and self.destroyed) then return end
	tf = (not not tf) and not self.args.never_show
	local state_change = (tf ~= self.last_state)
	if state_change then
		local flags = {ret_value = true}
		dump("Sending callback dotmarks_on_before_prompt_visibility_change for prompt %s | %s", self.uid, nameid(get_mark_name(self.args.id), self.args.id))
		SendScriptCallback("dotmarks_on_before_prompt_visibility_change", mark, self, tf, flags)
		if not (flags and flags.ret_value) then
			dl("[%s][%s] Prompt visibility change canceled by callback", time_global(), self.uid)
			return
		end
	end
	reason = reason and (" (" .. reason .. ")") or ""
	self.peak_hold = nil
	--local _ = debug_dump and vl("ShowPrompt %s: %s%s", self.active_prompt, tf, reason)
	self.line:SetProgressPos(tf and (not cfg.hide_connecting_line) and 1 or 0)
	if self.longpress and not tf then
		self.longpress:SetProgressPos(0)
	end
	self.disabled = not tf

	if self.last_state ~= self.disabled then
		vl("[%s] ShowPrompt %s: %s%s", time_global(), self.active_prompt, tf, reason)
		self.last_state = self.disabled
		self:OnVisibilityChange(tf, reason)
		self:AnimateFade(tf)
	end
	
	if not self.fading_out then
		self:UpdatePromptVisibility(tf)
	end
end

--- @param text string
function InteractPrompt:Prefix(text)
	if text then self.active_prefix = text end
	return (text or self.active_prefix or (self.args and self.args.act) or "")
end

--- @param text string
function InteractPrompt:Prompt(text)
	if text then self.active_prompt = text end
	return (text or self.active_prompt or (self.args and self.args.text) or "")
end

--- @param text string
function InteractPrompt:Suffix(text)
	if text then self.active_suffix = text end
	return (text or self.active_suffix or (self.args and self.args.suffix) or "")
end

--- @param prefix string
--- @param prompt string
--- @param suffix string
function InteractPrompt:GetFullPrompt(prefix, prompt, suffix)
	return self:Prefix(prefix) .. self:Prompt(prompt) .. self:Suffix(suffix)
end

--- @param new_prefix string
--- @param new_prompt string
--- @param new_suffix string
function InteractPrompt:SetPrompt(new_prefix, new_prompt, new_suffix)
	local new_text  = self:GetFullPrompt(new_prefix, new_prompt, new_suffix)
	local color_text, plain_text
	if self.parse_text_colors then
		color_text = parse_color_tokens(new_text, nil, true)
		plain_text = parse_color_tokens(new_text, nil, false)
	end
	local _ = debug_dump and vl("InteractPrompt:SetPrompt(%s, %s, %s) | %s", new_prefix, new_prompt, new_suffix, new_text)
	self.label:TextControl():SetText(color_text or new_text)
	self.label_sh:TextControl():SetText(plain_text or new_text)
	self.lref:TextControl():SetText(plain_text or new_text)
	self.lref:AdjustWidthToText()
	local pos = self:UpdatePromptLength()
	setwndsize(self.drop, pos + fontscale_w(cfg.interact_drop_w or 55), fontscale_h(cfg.interact_drop_h or 25))
end

function InteractPrompt:UpdateLongPress()
	if self.longpress and not self.args.pri then
		local mark = self:GetMark()
		--dump("[%s] InteractPrompt:UpdateLongPress", time_global())
		if mark and mark.is_active and (not self.busystate) and (cfg.held_key == self.args.key) and (cfg.held_mod == self.args.mod) then
			self.peak_hold = time_continual() - (cfg.held_time or 0)
			local prog = (self.peak_hold / self.hold_time)
			self.longpress:SetProgressPos(prog)
			CUIScriptWnd.Update(self)
		else
			self.peak_hold = nil
			self.longpress:SetProgressPos(0)
		end
	end
end

--- @param raw_text string
--- @param loc_string string
--- @param trimmed_text string
function InteractPrompt:on_quickhelp_text_update(raw_text, loc_string, trimmed_text)
	--dump("on_quickhelp_text_update | %s | %s | %s", raw_text, loc_string, trimmed_text)
	if not (loc_string and self.prompts[loc_string]) then return end
	if self.args.refresh_text then
		self.args.text = trimmed_text
		self:SetPrompt(nil, self.args.text)
		return
	end        
end

function InteractPrompt:UpdateFilteredHints()
	if not (self.prompts and (self.args.is_door or self.args.is_button or self.args.is_workshop or is_already_target(self.args.id))) then return end
	local hint
	for k,v in pairs(self.prompts) do
		hint = v() or self.args.default_text
		if self.args.refresh_text then
			if hint then
				self.args.text = hint
				self:SetPrompt(nil, self.args.text)
				return
			end            
		end
	end
	return hint
end

function InteractPrompt:UpdateMutantLootPrompt()
	if is_dead_mutant(self.args) and self.args.section then
		local can_loot, loot_msg = can_chop_body(self.args.section)
		local changed = (loot_msg ~= self.last_loot_msg)
		self.last_loot_msg = loot_msg
		local prefix = (not can_loot) and gts("st_alti_cannot") or nil
		self:Suffix(can_loot and "" or (loot_msg and (": " .. gts(loot_msg))) or "")
		self:BusyState(not can_loot, prefix, changed)
	end
end

function InteractPrompt:UpdateAnimBusyState()
	if anims_enabled and cfg.prompt_busy_during_anim and not self.busy_locked then
		self:BusyState(anim_playing)
	end
end

function InteractPrompt:UpdatePrimaryInteractText()
	if self.args.iedmode then
		self.active_prompt = self.args.iedtext .. " " .. get_ied_text()
		-- Update IED text
		return
	elseif self.prompts then
		-- Skip any markers checked against hint filters
		return
	end

	-- Check any special cases that slip through	
	if (
		self.door or
		(not self.args.text) or
		(self.args.text == "")
	) then
		local hint = hintfilters.last_raw_text and trimmed_prompt(hintfilters.last_raw_text)
		self:SetPrompt(nil, hint or self.args.text or "")
	end
end

function InteractPrompt:CheckForStuckTutorial()
	_ = (not self.init_done) and vl("Updates for this type are handled in main loop")
	if self.args.tutorial and (time_global() - self.init_done > 1000) then
		local monitor_active = state_monitor(self.args.tutorial)
		if ((not monitor_active) or (not game.has_active_tutorial())) then
			vl("No active tutorial, destroying prompt")
			self:Destroy("no active tutorial for " .. self.args.tutorial)
			return
		end
	end
end

--- @param last_aid string
--- @param qty number
function InteractPrompt:GetWoundedSuffix(last_aid, qty)
	if (last_aid ~= self.avail_aid) then
		self.aid_multi = nil
	end
	self.aid_multi = self.aid_multi or IsItem("multiuse", self.avail_aid)
	local text = string.format(" (%s %s%s)", qty or 0, self.aid_multi and (gts("st_alti_uses").." ") or "", gts("st_alti_owned"))
	return text
end

function InteractPrompt:CheckWoundedStalkers()
	self.avail_aid = nil
	local mark = self.args.id and cfg.markers[self.args.id]
	local last_aid = self.avail_aid
	self.avail_aid = cheapest_medical_help_owned()
	local qtyowned  = actor_aid_item_count(self.avail_aid) or 0
	if qtyowned < 1 then
		dump("InteractPrompt:CheckForWoundedStalkers found no health items")
		self.avail_aid = nil
		self:ShowPrompt(false)
		return
	end
	--dump("Generating heal prompt text for aid item %s", self.avail_aid)
	self.wounded_string = self.wounded_string or gts("st_alti_heal")
	local use_aid_name = gts(inventory_name(nil, self.avail_aid, true))
	self.args.text  = string.format(self.wounded_string, use_aid_name, mark and mark.name)
	local suffix = self:GetWoundedSuffix(last_aid, qtyowned)
	self:SetPrompt(nil, self.args.text, suffix)
	self:UpdateAnimBusyState()
end

function InteractPrompt:actor_on_update()
	if self.args.func_destroy and self.args.func_destroy(self) then
		self:Destroy("func_destroy returned true")
		return
	end
	if self.destroyed or cfg.killswitch_all then return end
	local _ = debug_dump and vl("[%s][%s]InteractPrompt:actor_on_update | %s%s", self.args.id, self.args.event, self.init_done and "" or "first run at ", time_global())
	self:UpdateFilteredHints()

	local mark = self:GetMark()

	if mark and mark.is_part_cnd then
		update_mark_condition(mark, not self.disabled)
		local obj = get_game_object(self.args.id)
	end

	if (self.args.tutorial or (mark and mark.is_stalker)) then
		self:CheckForStuckTutorial()
		self:CheckCampfireStates()
		self:UpdateMark()
		_ = (not self.args.pri) and mark and mark.is_wounded and self:CheckWoundedStalkers()
		self:UpdateLongPress()
		return
	end

	if self.disabled then return end

	if self.args.pri then
		self:UpdatePrimaryInteractText()
		self:UpdateFaveJunkIcon()
		self:UpdateMutantLootPrompt()
	else
		self:UpdateLongPress()
	end

	self:UpdateAnimBusyState()
end

--- @param reason string
function InteractPrompt:Destroy(reason)
	self:ShowPrompt(false)
	self:HideDialog()
	self.hint_filters   = nil
	self.destroyed      = true
	if self.linked_mark and self.linked_mark.use_pri then
		update_marker_active_state(self.linked_mark, false)
		self.linked_mark:ActiveSwap(false)
		self.linked_mark.use_pri:ShowPrompt(false)
	end
	get_hud():RemoveDialogToRender(self)
	
	if reason then
		vl("[InteractPrompt:Destroy][%s][%s]", self.args.id, reason)
	end
end

-- =======================================================================
--      MAIN LOGIC
-- =======================================================================

--- @param id number
function init_target_metadata(id, meta_dat)
	if not cfg.target_data[id] then
		cfg.target_data[id] = {}
	end
	if meta_dat ~= nil and not cfg.target_data[id][meta_dat] then
		cfg.target_data[id][meta_dat] = {}
	end
end

--- @param id number
function set_target_data(id, meta_dat, result)
	if not (id and meta_dat) then return end
	init_target_metadata(id, meta_dat)
	cfg.target_data[id][meta_dat].result = result
	return result
end

--- @param id number
function get_metadata_record(id, meta_dat)
	return id and meta_dat and cfg.target_data[id] and cfg.target_data[id][meta_dat]
end

--- @param id number
function get_target_data(id, meta_dat)
	return id and meta_dat and cfg.target_data[id] and cfg.target_data[id][meta_dat] and cfg.target_data[id][meta_dat].result
end

--- @param id number
function ismeta_mutant(id)
	return get_target_data(id, cfg.metadata_types.is_mutant)
end

function ismeta_container(id)
	return get_target_data(id, cfg.metadata_types.is_container)
end

function ismeta_pickup(id)
	return get_target_data(id, cfg.metadata_types.is_pickup)
end

function ismeta_empty_mutant(id)
	return get_target_data(id, cfg.metadata_types.empty_mutant)
end

--- @param args table
--- @param id number
function is_dead_mutant(args, id)
	if id and not args then
		args = get_mark(id)
	end
	if args then
		return args.is_mutant and not args.is_alive
	end
end

--- @param id number
function is_empty_mutant_corpse(id)
	if not is_dead_mutant(nil, id) then return end
	if get_metadata_record(id, cfg.metadata_types.is_empty_mutant) then
		return ismeta_empty_mutant(id)
	end
	local obj = id and get_game_object(id)
	local looted = obj and se_load_var(id, obj:name(), "looted")
	local st = db.storage[id]
	local decayed = (st and st.death_time and game.get_game_time():diffSec(st.death_time) > cfg.mutant_decay_time)
	local empty = (looted or decayed)
	--dump("is_empty_mutant_corpse: %s | looted %s | decayed %s", empty, looted, decayed)
	return empty and set_target_data(id, cfg.metadata_types.is_empty_mutant, empty)
end

--- @param section string
function can_chop_body(section)
	if not section then return end
	local result, tip
	if (item_knife.is_equipped()) then
		if (item_knife.get_condition() < 0.15) then
			tip = "st_body_knife_bad"
		elseif (not item_knife.can_loot(section)) then
			tip = "st_body_knife_weak"
		else
			result = true
			tip = "st_body_loot"
		end
	else
		tip = "st_body_knife_needed"
	end
	return result, tip
end

function is_actor_in_sleep_zone()
	for k,v in pairs(ui_sleep_dialog.sleep_zones) do
		if utils_obj.npc_in_zone(db.actor, v) then
			return true
		end
	end
end


function get_current_target()
	dump("current target: %s | L %s | T %s", locked_id or targeted_id, locked_id, targeted_id)
	return locked_id or targeted_id or nil
end

--- @param id number
function is_current_target(id)
	if not id then return end
	local curr_target = get_current_target()
	--dump("id %s is %sthe current target", id, curr_target and (id == curr_target) and "" or "not ")
	return curr_target and (id == curr_target)
end

function get_current_target_obj()
	local id = get_current_target()
	return id and get_game_object(id) or nil
end

--- @param id number
function is_target_pickup(id)
	id = id or get_current_target()
	if get_metadata_record(id, cfg.metadata_types.is_pickup) then
		return get_target_data(id, cfg.metadata_types.is_pickup)
	end
	local result = id and (id == cfg.available_pickup) or (cfg.markers[id] and cfg.markers[id].is_pickup)
	return set_target_data(id, cfg.metadata_types.is_pickup, result)
end

--- @param id number
--- @param cls number
function is_target_container(id, cls)
	id = id or get_current_target()
	if get_metadata_record(id, cfg.metadata_types.is_container) then
		-- Get cached result if it exists
		return ismeta_container(id)
	end
	local result, obj
	result = get_mark(id) and get_mark(id).is_container
	if not result then
		obj = get_game_object(id)
		cls = cls or (obj and obj:clsid())
		if (obj and cls) then
			result = (IsInvbox(nil, cls) or (IsStalker(nil, cls) and not (obj:alive())))
		else
			result = false
		end
	end
	return set_target_data(id, cfg.metadata_types.is_container, result)
end

--- @param tid string
function state_monitor(tid)
	if not tid then return end
	local state = tuthooks and tuthooks.monitors and tuthooks.monitors[tid] and tuthooks.monitors[tid].state
	local conds = state and cfg.state_conds and cfg.state_conds[tid] or nil
	local cond  = true
	if state and (conds ~= nil) then
		cond = conds(tid)
	end
	cfg.monitors[tid] = state and cond or false
	return cfg.monitors[tid]
end

--- @param tf boolean
function show_interaction_dots(tf)
	cfg.hide_interaction_dots = not tf
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function get_physpickup_name(mark)
	local text

end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function get_physpickup_action_text(mark)
	local text
	if mark.is_glowstick then
		text = gts("st_alti_take").." "..mark.name
	elseif mark.is_disarmable then
		text = gts("st_alti_disarm") .." "..trimmed_prompt(mark.name)
	end
	return text
end

--- @param id number
function take_glowstick(id)
	local obj = id and get_game_object(id)
	if (obj and obj:section() == "lights_glowstick") then
		local glowsticks = zz_glowstick_mcm.glowsticks
		local pos2d = game.world2ui(obj:position())
		if (pos2d.x < 350 or pos2d.x > 750 or pos2d.y < 250 or pos2d.y > 500) then return end
		if (not obj:get_hanging_lamp():is_on()) then return end

		local section = glowsticks[id] and glowsticks[id][1] or "device_glowstick"
		local con_d = glowsticks[id] and glowsticks[id][2]
		local newid = alife_create_item(section, db.actor, {cond = con_d}).id
		glowsticks[id] = nil
		alife_release_id(id)
		CreateTimeEvent("glowstick", "try_draw_on_take", 0.1, zz_glowstick_mcm.try_draw_on_take, newid)
	end
end

-- =======================================================================
-- 		DEPENDENCY CHECK
--	Checks all hard dependencies one by one, logs which ones fail, and 
--	shows an appropriate message to the user at the end.
-- =======================================================================
--- @param silent boolean
--- @param debug_test number
function check_for_dependencies(silent, debug_test)
	dl("[%s] Checking for dependencies", time_global())
	local failmessage
	local no_config             = not cfg
	dl("config loaded: %s", not no_config)
	-- Trap load failure

	dl("using_modded_exes: %s", using_modded_exes)
	-- Modded exes are a hard requirement, nothing will function without them

	local exes_version          = MODDED_EXES_VERSION or (get_modded_exes_version and get_modded_exes_version()) or 0
	local no_callback_old_exes   = (exes_version < 20250306)
	dl("no_callback_old_exes: %s", no_callback_old_exes)
	-- Modded exes found, but too old to support actor_on_update_pickup callback

	local no_callback_old_dbs   = (_G.CPickupModeUpdate_COD == nil) or not cfg.update_pickup_firing
	dl("no_callback_old_dbs: %s | found in _G %s | callback firing %s", no_callback_old_dbs, not (_G.CPickupModeUpdate_COD == nil), cfg.update_pickup_firing)
	-- Modded exes up to date, but stale DB files causing missing callback

	local no_lookat_method      = (exes_version < 20250225) or (not db.actor.get_actor_object_looking_at)
	dl("no_lookat_method: %s", no_lookat_method)
	-- Modded exes found, but too old even to support get_actor_object_looking_at

	local bad_mcm_version       = not valid_mcm_version(true)
	local ui_functors           = not not (ui_mcm and ui_mcm.UI_MCM and ui_mcm.UI_MCM.Init_Wrapper_Box)
	local mcm_version           = ui_mcm and ui_mcm.VERSION or "NOT FOUND"
	dl("bad_mcm_version: %s", bad_mcm_version)
	-- Version of MCM older than 1.7.0

	local no_hud_mark_manager   = (not hmm)
	dl("no_hud_mark_manager: %s", no_hud_mark_manager)
	-- HUD Mark Manager not found, which is really bad because we should've asserted by now

	local epic_fail             = (not using_modded_exes) or
									no_callback_old_exes or
									no_callback_old_dbs or
									no_hud_mark_manager or
									no_pickup_callback or
									no_lookat_method or
									bad_mcm_version or
									no_config
	if not (epic_fail or debug_test) then return end
	cfg = cfg or {}
	cfg.killswitch_all = true
	set_handler_callbacks(true)
	alert("Dependency check failed!")

	if (not using_modded_exes) or (debug_test and debug_test == 1) then
		failmessage         = gts("st_dotmarks_fail_reason_noexes") ..
							gts("st_get_modded_exes")

	elseif no_callback_old_exes or (debug_test and debug_test == 2) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldexes"), 20250306, exes_version) ..
							gts("st_get_modded_exes")

	elseif no_lookat_method or (debug_test and debug_test == 3) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldexes"), 20250225, exes_version) ..
							gts("st_get_modded_exes")

	elseif no_callback_old_dbs or (debug_test and debug_test == 4) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_staledbs"), exes_version) ..
							gts("st_get_modded_exes")

	elseif bad_mcm_version or (debug_test and debug_test == 5) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldmcm"), mcm_version, ui_functors) ..
							gts("st_catsy_get_mcm")

	elseif no_hud_mark_manager or (debug_test and debug_test == 6) then
		failmessage         = gts("st_dotmarks_fail_reason_nohmm")

	elseif no_config or (debug_test and debug_test == 7) then
		failmessage         = gts("st_dotmarks_fail_reason_nocfg")
	end

	if failmessage then
		failmessage = gts("st_dotmarks_epicfail_error") .. failmessage .. gts("st_catsy_failmessage_in_log_or_pda")
		local log_msg = parse_color_tokens(failmessage, nil, false)
		alert(log_msg)
		if silent and not debug_test then
			return epic_fail
		end

		failmessage = parse_color_tokens(failmessage)
		CreateTimeEvent("dotmarks_dependency_warning", 0, 4, (
			function()
				dotip(failmessage, 10000, "Interaction Dot Marks", true, "ui_inGame2_V_zone_nedavno_proshel_vibros")
				return true
			end
		))
	end
	return true
end

function actor_on_first_update()
	hmm = utils_catspaw_hudmarks and utils_catspaw_hudmarks.get_hud_mark_manager()
	CreateTimeEvent("dotmark_scan_delay", 0, cfg.scan_start_delay, start_scanning)
	maingameui = ActorMenu.get_maingame()
	xml = CScriptXmlInit()
end

function show_welcome_message()
	if cfg.welcome_message_shown then return end
	cfg.welcome_message_shown = true
	ui_mcm.set("dotmarks/dmarkmain/welcome_message_shown", true)
	local st_ver = cfg.upgrade_settings_defaulted and gts("st_dotmarks_upgrade_defaulted") or ""
	CreateTimeEvent("dotmarks_welcome_message", 0, 5, (
		function()
			local welcome = parse_color_tokens(string.format(gts("st_dotmarks_welcome_message"), script_version, st_ver))
			dotip(welcome, 8000, "Interaction Dot Marks", true, "ui_inGame2_V_zone_nedavno_proshel_vibros")
			return true
		end
	))
end

function start_scanning()
	if check_for_dependencies(false) then return true end
	show_welcome_message()
	scanning = true
	if utils_catspaw_taskmonitor then
		utils_catspaw_taskmonitor.set_monitor_active(true)
	end
	return true
end

function stop_scanning()
	scanning = false
	if utils_catspaw_taskmonitor then
		utils_catspaw_taskmonitor.set_monitor_active(false)
	end
	return true
end

function actor_on_net_destroy()
	stop_scanning()
end

--- @param item_class string
function is_object_scannable(item_class)
	return not not (item_class and cfg.scan[item_class])
end

--- @param id number
function get_args_for_valid_objects(id)
	tracelog("start", "get_args_for_valid_objects", id)
	local obj 	= get_game_object(id)
	if not obj then return end

	local cls 	= obj:clsid()
	local sec 	= obj:section()
	local kind 	= get_obj_kind(obj)
	local name 	= obj:name()
	vl("get_args_for_valid_objects: %s - clsid %s", nameid(name, id), cls)
	if is_blacklisted(id, cls, sec, kind) then
		local _ = debug_dump and vl("Object matched one or more blacklists: id %s | cls %s | sec %s | kind %s | name %s", cfg.blacklisted_ids[id] and id, cfg.blacklisted_clsids[cls] and cls, cfg.blacklisted_sections[sec] and sec, cfg.blacklisted_kinds[kind] and kind, cfg.blacklisted_names[name] and name)
		return
	end
	local args 	= { logged_type = "something else", name = cfg.names_by_section[sec], kind = kind, section = sec, clsid = cls, ret_value = true}

	local function setup_item_args(iclass, ...)
		args            = get_class_marker_args(iclass, obj, ...) or {}
		if args.iclass_override then
			iclass      = args.iclass_override
			args        = get_class_marker_args(iclass, obj, ...) or {}
		end
		args.item_class	= iclass
		args.id         = id
		args.clsid      = cls -- I had these commented out after working on HF stuff - why?
		args.kind       = kind -- this
		args.section    = args.inv_section or sec -- this too
		args.hidden     = args.hidden or not is_object_scannable(iclass)
		args.has_power  = sec and (item_device.dev_consumption[sec] or (sec == "batteries_dead")) or nil
	end

	local method
	local stype = get_type_for_section(sec)
	dump("Sending callback dotmarks_on_new_object_scan for %s", nameid(obj))
	SendScriptCallback("dotmarks_on_new_object_scan", id, args)
	if not (args and args.ret_value) then return end
	args.ret_value = nil
	if args.texture or args.item_class then
		vl("Returned for object by callback: texture %s | item_class %s", args.texture, args.item_class)
		method = 4
		if args.item_class then
			setup_item_args(args.item_class)
		end	--method = 3
		--end
	elseif stype then
		vl("Section %s found in lookup: %s", sec, stype)
		method = 0
		setup_item_args(stype)
	else
		local ktype = get_type_for_kind(kind)
		if ktype then
			vl("Kind %s found in lookup: %s", kind, ktype)
			method = 1
			setup_item_args(ktype)
		else
			for item_class, enabled in pairs(cfg.scan) do
				if (enabled or cfg.scan_unmarked_classes) and cfg.is_item[item_class] then
					local isitem, special = cfg.is_item[item_class](obj, sec, cls, kind)
					if isitem then
						vl("Type found via iteration: %s", item_class)
						setup_item_args(item_class, special)
						method = 2
						break
					end
				end
			end
		end
	end
		
	if not args.texture then
		local pid = cfg.available_pickup
		if (id == pid) then
			alert("Obj %s failed classification, but is detected by engine as a pickup!\n"..
				"$ Classifying \"Misc\" as a fallback, investigate: section %s | clsid %s | kind %s",
				nameid(nil, id), sec, cls, kind
			)
			setup_item_args("Misc")
		end
	end
	if not args.texture then
		dl("No args found for %s, no marker init | section %s | clsid %s | kind %s", nameid(nil, id), sec, cls, kind)
		tracelog("end", "get_args_for_valid_objects", id)
		return
	end

	local method_txt = (method > 3) and "callback" or (method > 2) and "addon" or (method > 1) and "iteration" or (method > 0) and "kind" or "section"
	dl("[DotMarks] get_args_for_valid_objects: %s classification is %s (matched by %s) | section %s | kind %s", nameid(obj), args.logged_type, method_txt, sec, kind)
	tracelog("end", "get_args_for_valid_objects", id)
	return args
end

-- =======================================================================

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param args table
function setup_pri_interact_prompt(mark, args)
	dl("[%s] setup_pri_interact_prompt for %s", mark.mark_id or "fixed interaction", args and (args.name or args.logged_type) or "unknown type with no passed args")
	if not mark then return end
	if mark.use_pri then
		mark.use_pri:Destroy("re-init of existing prompt")
		mark.use_pri = nil
	end
	args            = args or {}
	local key       = bind_to_dik(key_bindings.kUSE)
	local bind_text = bindtext(key, 0)
	local int_text  = trimmed_prompt(get_quickhelp_text())
	local verb 		= mark.verb_primary

	if mark.is_pickup then
		if mark.physics_obj then
			int_text = get_physpickup_action_text(mark)
		else
			int_text = nil
		end
		if not int_text then
			int_text = string.format("%s %s", gts(verb or "st_alti_take"), (mark.money or mark.name))
		end
	elseif mark.is_stalker and mark.is_alive then
		int_text = string.format("%s %s", gts(verb or "st_alti_speak"), mark.name)
	elseif mark.is_door then
		int_text = int_text or trimmed_prompt(gts("car_character_use"))
	elseif mark.is_container then
		int_text = string.format("%s %s", gts(verb or "st_alti_search"), mark.name)
	elseif (mark.is_npc and not mark.is_alive) then
		int_text = gts("st_body_loot")
	elseif mark.hf_workshop then
		int_text = nil
	end

	args.name 		= mark.name or args.name or nil
	args.text   	= int_text
	args.bind 		= bind_text
	args.func		= args and args.func_exec_pri or (function() end)
	args.event		= "pri_interact"
	args.ret_value 	= true

	dump("Sending callback dotmarks_on_setup_pri_interact for %s", nameid(mark.name, mark.id))
	SendScriptCallback("dotmarks_on_setup_pri_interact", args, mark)
	if args and args.ret_value then
		args.ret_value 	= nil
		args.pri 		= true
		args.key 		= key
		args.mod 		= 0
		mark.use_pri 	= InteractPrompt(args.anchor or mark.marker or maingameui, args)
	end
	return mark.use_pri
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function setup_sec_interact_prompt(mark)
	if not mark then return end
	if mark.alt_interact then return end
	if mark.checked_for_sec then return end
	local id        = mark.id
	dl("[%s][%s] setup_sec_interact_prompt for %s", id, mark.mark_id, mark.name)
	local obj 		= get_object_by_id(id)
	local section   = obj and obj:section()
	local mode      = cfg.imod_sec_interact
	local name 		= mark.name
	local verb 		= mark.verb_secondary
	local args = {
		id      	= id,
		text    	= mark.verb_secondary and gts(mark.verb_secondary) or "",
		act     	= (mode == 2) and gts("st_alti_hold").." " or (mode == 1) and gts("st_alti_doubletap").." " or "",
		bind    	= bindtext(cfg.bind_sec_interact, cfg.modk_sec_interact),
		long    	= (mode == 2),
		func    	= mark.func_exec_sec or handle_secondary_interact,
		event 		= "sec_interact",
		ret_value 	= true
	}

	dump("Sending callback dotmarks_on_setup_sec_interact for %s | verb_secondary: %s\n"..
		"id %s | bind %s | long %s | event %s | act %s | text %s | custom func %s",
		nameid(mark.name, mark.id), mark.verb_secondary or "default",
		args.id, args.bind, args.long, args.event, args.act, args.text, not not mark.func_exec_sec
	)

	SendScriptCallback("dotmarks_on_setup_sec_interact", args, mark)
	local callback_skip = (mark and mark.checked_for_sec) and true or false

	if not mark then
		alert("WARNING: Mark %s (%s) seems to have been destroyed during callback, aborting prompt setup", name, id)
		return
	end
	mark.checked_for_sec = true
	if not (args and args.ret_value) then
		dl("Prompt setup canceled by callback, skipping secondary interact")
		return
	end
	args.ret_value 	= nil
	if callback_skip then
		dl("Secondary checks for ID %s handled by callback, skipping further checks and beginning setup of prompt", id)
	else
		vl("No override from callback, checking for item-specific args")
		obj = id and get_game_object(id)
		-- reinit object after callback to be sure it still exists
		if obj and IsWeapon(obj) then
			if not cfg.sec_enable_unload_act then return end
			dump("Setting up unload_and_take_ammo secondary action")
			-- Weapon containing ammunition/parts
			local atype     = obj:get_ammo_type() + 1
			local ammos     = parse_list(ini_sys, obj:section(), "ammo_class")
			local sec       = ammos and atype and ammos[atype]
			local ammo      = find_best_localization(nil, nil, sec)
			args.text   = string.format(gts("st_alti_prompt_ammo"),
				mark.verb_secondary or mags_installed and gts("st_alti_eject_mag") or gts("st_alti_unload_weapon"),
				ammo,
				mark.ammo_count,
				gts("st_alti_from"),
				mark.name
			)
			args.func = unload_and_take_ammo
		elseif mark.inspect_anim then
			if not cfg.sec_enable_arty_anim then return end
			-- Artefact with an inspect animation
			dump("Setting up take_and_inspect secondary action for artefact")
			args.func = take_and_inspect
			args.text = string.format("%s %s",
				first_upper(gts(mark.verb_secondary or "st_alti_inspect")),
				mark.name
			)
		elseif mark.placeable_mine then
			dump("Setting up plant_bomb secondary action")
			args.iedmode = get_ied_text()
			if not args.iedmode then return end
			-- Placeable mine/IED
			args.text = string.format(
				gts(mark.verb_secondary),
				trimmed_prompt(mark.name)
			)
			args.func = plant_bomb
		elseif mark.is_wounded then
			dump("Setting up help_wounded_stalker secondary action")
			if not cfg.sec_enable_heal_act then return end
			-- Wounded stalker
			args.func = help_wounded_stalker
			args.func_valid = is_still_wounded
		elseif mark.is_container then
			if (not cfg.sec_enable_takeall_act) and not mark.always_show_sec then return end
			if mark.is_backpack then
				dump("Setting up pick_up_backpack secondary action")
				-- Pick up backpack and everything in it
				args.text = first_upper(gts(mark.verb_secondary))
				args.func = pick_up_backpack
			elseif z_auto_looter and cfg.takeall_does_autoloot and not mark.autolooted then
				dump("Setting up trigger_autoloot secondary action")
				-- Trigger iTheon's autoloot
				args.text = string.format("%s %s",
					first_upper(gts(mark.verb_secondary or "st_alti_autoloot")),
					mark.name
				)
				args.func = trigger_autoloot
			else
				dump("Setting up take_all_from_box secondary action")
				-- Take everything from box
				args.text = string.format("%s %s",
					first_upper(gts(mark.verb_secondary or "st_alti_takeall")),
					mark.name
				)
				args.func = take_all_from_box
			end
		--elseif (mark.kind == "i_letter") then
		elseif mark.is_readable then
			dump("Setting up take_and_read secondary action")
			if not cfg.sec_enable_use_act then return end
			-- Readable
			args.text        = string.format(gts("st_alti_prompt_usable"),
				gts(mark.verb_secondary),
				mark.name,
				gts("st_alti_now")
			)
			args.func = take_and_read
		elseif mark.has_battery then
			dump("Setting up unpack_batteries secondary action")
			if not cfg.sec_enable_unload_act then return end
			-- Device with battery power
			args.text        = string.format(gts("st_alti_prompt_usable"),
				first_upper(gts(mark.verb_secondary)),
				gts("st_alti_from"),
				mark.name
			) 
			args.func = unpack_batteries
		elseif cfg.is_item.Tools(obj) then
			dump("Setting up take_and_use secondary action for tool")
			if not cfg.sec_enable_use_act then return end
			-- Usable tool
			args.text = string.format(gts("st_alti_prompt_usable"),
				gts(mark.verb_secondary),
				mark.name,
				gts("st_alti_now")
			)
		elseif cfg.is_item.Consumables(obj) then
			dump("Setting up take_and_use secondary action for consumable")
			if not cfg.sec_enable_use_act then return end
			-- Consumable
			local verb = mark.verb_secondary or (
				(cfg.smokables[section] and "st_alti_smokeout") or
				(mark.kind == "i_medical") and "st_alti_use_booster" or
				"st_alti_consume_food"
			)
			args.text        = string.format(gts("st_alti_prompt_usable"),
				gts(verb),
				mark.name,
				gts("st_alti_now")
			)
		elseif (mark.clsid == clsid.equ_backpack) then
			dump("Setting up deploy_backpack secondary action")
			-- Backpack inventory item
			args.text        = string.format("%s %s",
				first_upper(gts(mark.verb_secondary or "st_alti_deploy_bp")),
				mark.name
			)
			args.func = deploy_backpack
		else
			if not cfg.sec_enable_use_act then return end
			-- Fallback to generic "use" prompt
			dump("Falling back to generic usage secondary action")
			args.text        = string.format(gts("st_alti_prompt_booster"),
				gts(mark.verb_secondary or "st_alti_takeuse"),
				mark.name,
				gts("st_alti_now")
			)
		end
	end

	args.mark = mark
	args.name = args.name or mark.name
	mark.alt_interact = InteractPrompt(args.anchor or mark.marker or maingameui, args)
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function set_secondary_action(mark)
	if not mark then return end
	if mark.alt_interact then
		mark.alt_interact:Destroy("reinit as something else")
		mark.alt_interact = nil
	end
	setup_sec_interact_prompt(mark)
end

-- =======================================================================

local scanned = {}

--- @param id number
function unregister_scanned_entity(id, rescan_delay)
	if not id then return end
	rescan_delay = tonumber(rescan_delay) or 0
	CreateTimeEvent(
		"rescan_delay" .. tostring(id), 0, rescan_delay, (
			function()
				scanned[id] = nil
				return true
			end
		)
	)
	if (locked_id == id) then
		locked_id = nil
	end
	if (targeted_id == id) then
		targeted_id = nil
	end
	local ind = pickup_index[id]
	if ind then
		pickup_index[id] = nil
		nearby_pickups[ind] = nil
	end
	cfg.invboxes[id] = nil
	pickup_index[id] = nil
	cfg.target_data[id] = nil
	cfg.in_pickup_range[id] = nil
	if cfg.markers[id] then
		local mark = cfg.markers[id]
		if mark.use_pri then
			mark.use_pri:Destroy("unregistering pri use" .. id)
		end
		if mark.alt_interact then
			mark.alt_interact:Destroy("unregistering sec use")
		end
		if mark.preset then
			destroy_marker(mark.mark_id, "unregister_scanned_entity")
		else
			destroy_prompt(id, "unregister_scanned_entity")
		end
	end
	

	vl("[%s] Unregistering scanned entity for %s and nulling all pointers to it", time_global(), nameid(name, id))
end

--- @param val number
--- @param reason string
function set_loot_window_flag(val, reason)
	local last = cfg.block_loot_window
	cfg.block_loot_window = val
	local text = val and "Setting to: " or "Clearing"
	if (last == val) then return end
	vl("[%s] Flag cfg.block_loot_window: %s%s%s", time_global(), text, val or "", reason and (" ("..reason..")") or "")
end

function clear_loot_window_flag(reason)
	set_loot_window_flag(nil, reason)
end

--- @param id number
function mark_is_shown(id)
	return id and cfg.markers[id] and cfg.markers[id].is_shown
end

--- @param id number
function marked_obj_has_ammo(id)
	return id and cfg.markers[id] and (cfg.markers[id].ammo_count and cfg.markers[id].ammo_count > 0)
end

--- @param id number
--- @param dist number
function can_interact_physpickup(id, dist, skip_pickup_check)
	if (not dist) or (dist > get_interact_distance(id)) then return false end
	local obj 	= id and get_game_object(id)
	if not skip_pickup_check then
		if not is_object_physpickup(obj and obj:section()) then return end
	end
	local pos   = obj:position()
	local dot   = pos and utils_catspaw_hudmarks and utils_catspaw_hudmarks.dotproduct_for_pos(pos) or 0
	return dot >= (cfg.target_lenience)
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function can_interact_physmark(mark)
	if not mark then return end
	return can_interact_physpickup(mark.id, mark.last_dist, true)
end

function get_best_hover()
	return hmm and hmm.best_hover_id, hmm and hmm.best_hover_dp
end

function best_hovered_id()
	local id, dot = get_best_hover()
	return dot and (dot >= cfg.target_lenience) and id
end

--- @param obj game_object
--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function obj_has_available_sec_interact(obj, id, mark)
	if not (obj or id) then return end
	if (not mark) or (mark.no_sec or mark.is_display) then return false end

	id = id or (obj and safeid(obj))
	obj = obj or (id and get_game_object(id))
	if not obj then return end

	local object_class 	= "none"
	local has_interact 	= false
	local section 		= obj:section()
	local cls       	= obj:clsid()
	local is_melee      = IsMelee(nil, cls)

	if mark.func_setup_sec then
		object_class = "has func_setup_sec (Allowed)"
		has_interact = true
	elseif cfg.useless_shit[section] then
		object_class = "useless_shit (Banned)"
	elseif is_melee then
		object_class = "melee_weapon (Banned)"
	elseif (not not mark.money) then
		object_class = "is_money (Banned)"
	elseif marked_obj_has_ammo(id) and not is_melee then
		object_class = "has_ammo (Allowed)"
		has_interact = true
	elseif cfg.is_item.Consumables(obj) then
		object_class = "is_consumable (Allowed)"
		has_interact = true
	elseif (mark and mark.is_readable) then
		object_class = "is_readable (Allowed)"
		has_interact = true
	elseif (mark and mark.has_battery) then
		object_class = "has_battery (Allowed)"
		has_interact = true
	elseif (mark and mark.is_backpack) then
		object_class = "is_backpack (Allowed)"
		has_interact = true
	elseif (mark and mark.placeable_mine) then
		object_class = "placeable_mine (Allowed)"
		has_interact = true
	elseif not not (mark and mark.inspect_anim) then
		object_class = "inspectable (Allowed)"
		has_interact = true
	elseif (mark.is_container or mark.hf_workshop or mark.hf_secondary) then
		object_class = "furniture (Allowed)"
		has_interact = true
	end

	vl("[obj_has_available_sec_interact] %s | classification: %s", has_interact, object_class)
	return has_interact
end

--- @param id number
--- @param args table
function setup_marker_for_object(id, args)
	local obj = get_game_object(id)
	if not obj then return end

	tracelog("start", "setup_marker_for_object", id)
	local sec = obj:section()
	local cls = obj:clsid()

	vl("Passing the following args to utils_catspaw_hudmarks:")
	for k,v in pairs(args) do
		vl("%s = %s", k, v)
	end

	if not cfg.markers then cfg.markers = {} end
	cfg.markers[id] = hmm:AddMarker(args)
	local mark = cfg.markers[id]
	if mark.is_pickup then
		if cfg.pickup_los_pos_adj and not mark.los_pos_adjust then
			mark.los_pos_adjust = vector():set(0, cfg.pickup_los_pos_adj, 0)
		end
	end
	local has_cond 	= (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
	local is_mag 	= magazine_binder and sec and magazine_binder.is_magazine(sec)
	if has_cond and not is_mag then
		mark.condition = obj and obj:condition()
	end
	dump("Sending dotmarks_on_marker_init for %s", nameid(args.name, id))
	SendScriptCallback("dotmarks_on_marker_init", args, mark)

	if (not cfg.hide_pri_interact_ui) then
		if not (args.no_pri) then
			setup_pri_interact_prompt(mark, args)
		end
		if mark.use_pri and obj_has_available_sec_interact(obj, id, mark) and not (args.no_sec) then
			setup_sec_interact_prompt(mark)
		end
	end
	if (not mark.active_swap) and cfg.enable_icon_targetdot then
		mark.active_swap = cfg.swap_dotactive
	end
	mark.initial_pos 	= mark.last_pos or mark:GetPos(mark.pos_adjust)
	mark.initial_dist 	= mark.last_dist or distance_to_nearby_object(obj)
	pl("$ ", "[%s] New marker finalized %s for %s (%s):\n" ..
		"%s Primary interact: %s | %s\n" ..
		"%s Secondary interact: %s | %s\n" ..
		"= Obj name: %s | item_class %s | dist %s\n" ..
	 	"= marker pos %s | obj pos %s",
		time_global(),
		mark.mark_id, mark.name, mark.logged_type or "unknown type",
		
		mark.use_pri and "-" or "~",
		not not mark.use_pri,
		mark.use_pri and mark.use_pri:GetFullPrompt() or "",
		
		mark.alt_interact and "-" or "~",
		not not mark.alt_interact,
		mark.alt_interact and mark.alt_interact:GetFullPrompt() or "",
		
		obj:name(), mark.item_class or "none", mark.initial_dist, mark.initial_pos, obj:position()
	)
	tracelog("end", "setup_marker_for_object", id)
end

--- @param obj game_object
function distance_to_nearby_object(obj)
	if not (obj and db.actor) then return end
	local apos = db.actor:position()
	return apos:distance_to(obj:position())
end

--- @param obj game_object
--- @param max_dist number
--- @param test_dist number
function is_object_nearby(obj, max_dist, dist)
	return (dist or distance_to_nearby_object(obj) or 999) <= (max_dist or end_radius())
end

--- @param obj game_object
--- @param id number
function scan_nearby_object(obj, id)
	tracelog("start", "scan_nearby_object", id)
	id  = id or (obj and obj:id())
	if not valid_id(id) then return end
	obj = obj or (id and get_game_object(id))
	if not obj then return end
	local name = obj:name()

	if scanned[id] then
		-- Skip previously-scanned IDs if their name matches, otherwise clear the table entry assuming it's a reused ID
		if scanned[id] == name then
			tracelog("end", "scan_nearby_object", id)
			--dump("%s has already been scanned, skipping", nameid(name, id))
			return
		end
		dl("%s has a new name, assuming the ID has been reused and clearing entry", id)
		scanned[id] = nil
	end

	local m_id  = "dotmark_" .. tostring(id)
	hmm = hmm or utils_catspaw_hudmarks.get_hud_mark_manager()
	if not hmm then return end

	local cls = obj:clsid()
	local sec = obj:section()

	if hmm:GetMarker(m_id) then
		-- Already a marker for this ID, skip
	else
		if not is_object_nearby(obj) then
			dl("Tried to initialize marker for %s, but its current distance (%s) is outside the maximum (%s)", nameid(obj), distance_to_nearby_object(obj), end_radius())
			return
		end
		scanned[id] = name
		dl("Scanning unmarked object %s | clsid %s | [%s]", nameid(name, id), cls, sec)
		local args  = get_args_for_valid_objects(id)
		if not args then
			tracelog("end", "scan_nearby_object", id)
			return
		end

		args            = args or {}
		args.id         = id
		args.mark_id    = m_id
		args.name       = args.name or find_best_localization(obj, nil, sec) or nil
		args.preset     = "dotmark"
		args.ret_value 	= true

		dump("Sending dotmarks_on_before_marker_init for %s", nameid(args.name, id))
		SendScriptCallback("dotmarks_on_before_marker_init", args)
		if not args.ret_value then
			dl("Marker init for %s cancelled by callback, aborting", nameid(name, id))
			tracelog("end", "scan_nearby_object", id)
			return
		end
		args.ret_value = nil
		setup_marker_for_object(id, args)
	end

	tracelog("end", "scan_nearby_object", id)
end


--- @param scan_radius number
function scan_nearby_entities(scan_radius)
	--dump("[%s] scan_nearby_entities(%s)", scan_radius)
	local pos = db.actor and db.actor:center()
	if not pos then return end
	level.iterate_nearest(pos, scan_radius, scan_nearby_object)
	tracelog("end", "scan_nearby_entities", "radius: "..tostring(scan_radius))
end

--- @param position vector3
function dot_eye(position)
	-- Taken from Crook's Faction ID
	local toPoint = vector():set(position):sub(device().cam_pos):normalize()
	local toEye = device().cam_dir
	local dot = toPoint:dotproduct(toEye)
	return dot
end

--- @param method number
--- @param last_id number
local function log_target_acquisition(method, last_id)
	if not (debug_dump and method) then return end
	local target = targeted_id and get_game_object(targeted_id)
	if not target then return end
	local method_txt = ""
	if method < -1 then
		method = "manual"
	elseif method < 0 then
		target = last_id and get_game_object(last_id)
		if target then
			dump("[%s] update_targeted_object: no longer targeting %s", time_global(), nameid(target))
		end
		return
	elseif method > 1 then
		method_txt = "avail_pickup"
	elseif method > 0 then
		method_txt = "looking_at"
	else
		method_txt = "target_obj"
	end
	dump("[%s] update_targeted_object: targeted_id is now %s (%s) | method %s", time_global(), targeted_id, target and target:name(), method_txt)
end

--- @param obj game_object
--- @param id number
function is_marker_object_container(obj, id)
	id = id or (obj and obj:id())
	return id and cfg.markers[id] and cfg.markers[id].is_container
end

function update_targeted_object()
	tracelog("start", "update_targeted_object", targeted_id)
	local last_id = targeted_id
	local target, method

	if db.actor.get_actor_object_looking_at then
		-- 20250225 modded exes required for this method
		target = db.actor:get_actor_object_looking_at()
		method = 1
	elseif cfg.use_get_target_obj then
		-- Vanilla but very finicky, requires the object to be precisely under the crosshair
		target = level.get_target_obj()
		method = 0
	end
	if cfg.available_pickup and not is_marker_object_container(target) then
		target = get_game_object(cfg.available_pickup)
		method = 2
		-- 20250306 modded exes required for pickup callback
	end

	local id = target and target:id()
	if cfg.racked_items[id] then
		targeted_id = cfg.racked_items[id]
		target = get_game_object(targeted_id)
	else
		targeted_id = id
	end

	if targeted_id then
		if target and (method < 1) and cfg.fallback_distance_check and (targeted_id ~= last_id) then
			local apos = db.actor:position()
			local dist = apos:distance_to(target:position())
			if dist > (cfg.obj_interact_dist or 2.5) then
				targeted_id = nil
			end
		end
	else
		if cfg.use_hover_targeting then
			targeted_id = best_hovered_id()
		end
		if targeted_id then
			method = -2
		elseif last_id then
			method = -1
			return
		end
	end
	log_target_acquisition(method, last_id)
	tracelog("end", "update_targeted_object", targeted_id)
end

function can_play_pickup_anim()


end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param func_on_take function
function fake_take_anim(mark, func_on_take)
	if not (mark and mark.id) then
		alert("Invalid mark or id passed to fake_take_anim! | mark exists %s | id %s", not not mark, mark and mark.id)
		return
	end
	hide_hud_inventory()
	local pickup_functor = func_on_take or (
		function(self)
			pick_up_marked_item(mark)
		end
	)
	if not (anims_enabled and lam2 and liz_fdda_redone_item_pickup) then
		pickup_functor(mark.id)
		return
	end
	vl("Faking take animation for %s", mark.name)
	-- This is largely a stripped-down copy of the item-take animation function in FDDAR
	--if something other than pickup is playing right now, don't do anything
	if lam2.is_running() and not lam2.get_action_with_tag("item_pickup") then
		dump("FDDAR found No action with item_pickup tag")
		return
	end
	--if have body search in queue don't pickup items. Body search have priority
	if lam2.get_action_with_tag("body_search") then
		dump("FDDAR has an active body search animation, aborting take")
		return
	end

	local hand, anm_name
	local id 	= mark.id
	local wpn 	= db.actor:active_slot() ~= 0
	local det 	= db.actor:active_detector() or nil
	local rhf 	= (not wpn and not liz_fdda_redone_item_pickup.is_hand_busy(0)) == true and true or false
	local lhf 	= (not det and not liz_fdda_redone_item_pickup.is_hand_busy(1)) == true and true or false

	if rhf and lhf then
		hand = math.random(0,1)
		local al = {
			[0] = "anm_ea_taker",
			[1] = "anm_ea_takel"
		}
		anm_name = al[hand]
	elseif rhf then
		hand = 0
		anm_name = "anm_ea_taker"
	elseif lhf then
		hand = 1
		anm_name = wpn and "anm_ea_takelw" or "anm_ea_takel"
	elseif wpn and det then
		hand = 1
		anm_name = wpn and "anm_ea_takelw" or "anm_ea_takel"
	else
		return
	end

	liz_fdda_redone_item_pickup.set_hand_busy(hand, 1)

	local action = lam2.get_template_action_play_animation()
	action.tag = "item_pickup"
	action.name = "item_pickup_" .. hand
	action.hands = hand
	action.sec = "item_ea_take_hud"
	action.anm = anm_name
	action.anm_blend = true
	action.speed = cfg.fddar_pickup_speed or 1.2
	action.on_enter = function (self)
		liz_fdda_redone_item_pickup.set_hand_busy(self.hands, self.duration)
	end
	action.on_execute = function (self, time)
		if time > self.duration / 2 then
			if self.on_take then self:on_take() end
		end
		if time > self.duration / 2 then
			if self.is_short then
				return lam2.states.success
			end
		end
	end
	if id then
		action.on_take = (
			function(self)
				pickup_functor(mark.id)
			end
		)
	end
	local current_pickup_action = lam2.get_action_with_tag("item_pickup")
	if current_pickup_action then current_pickup_action.is_short = true end
	--]]
	lam2.add_action(action)
	return true
end

--- @param box game_object
--- @param id number
function get_inventory_table(box, id)
	-- Streamlined version of the one in axr_companions
	box = box or (id and get_game_object(id))
	local t = {}
	local i = 0
	if box then
		id = id or box:id()
		local function iterate(owner, item)
			i = i + 1
			local item_id = item:id()
			local item_sec = item:section()
			t[item_id] = item_sec
		end
		iterate_any_inventory(box, iterate)
	end
	return t, i
end

--- @param id number
function deploy_backpack(id)
	local backpack = get_game_object(id)
	local pos = backpack and backpack:position()
	if not pos then return end
	local actor = db.actor
	local se_obj = actor and alife_create("inv_backpack", pos, actor:level_vertex_id(), actor:game_vertex_id())
	local section = backpack:section()
	if (se_obj and se_obj.id and section) then
		local txt = string.format(gts("st_itm_stash_of_character"), db.actor:character_name())
		level.map_add_object_spot_ser(se_obj.id, "treasure", txt)
		actor_menu.set_msg(1, gts("st_stash_created"),4)
		
		local m_data = alife_storage_manager.get_state()
		if not (m_data.player_created_stashes) then 
			m_data.player_created_stashes = {}
		end
		
		m_data.player_created_stashes[se_obj.id] = section
		
		alife_release(backpack)
	end
end

--- @param id number
function remove_placed_backpack(id, mapspot)
	if not id then return end
	level.map_remove_object_spot(id, mapspot or "treasure")
	local se_obj = alife_object(id)

	if se_obj then
		alife_release(se_obj)
	end
	
	local m_data = alife_storage_manager.get_state()
	if (m_data.player_created_stashes and m_data.player_created_stashes[id]) then 
		local section = m_data.player_created_stashes[id]
		alife_create_item(section, db.actor)
		m_data.player_created_stashes[id] = nil
	end
	return true
end

--- @param box game_object
--- @param func function
function iterate_any_inventory(box, func)
	if not (box and func) then return end
	if IsStalker(nil, box:clsid()) then
		box:iterate_inventory(func)
	else
		box:iterate_inventory_box(func)
	end
end

--- @param who game_object
function cheapest_medical_help_owned(who)
	who = who or db.actor
	if not who then return end
	local medkit
	local medhelp = {
		[1] = "medkit",
		[2] = "medkit_army",
		[3] = "medkit_scientic",
		[4] = "stimpack",
		[5] = "stimpack_army",
		[6] = "stimpack_scientic"
	}
	for i = 1, #medhelp do
		medkit = medhelp[i]
		if medkit and who:object(medkit) then
			return medkit
		end
	end
end

--- @param section string
function actor_aid_item_count(section)
	if not db.actor then return end
	local num_owned = section and utils_item.get_amount(db.actor, section, 1) or 0
	return num_owned   
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param exec_func function
function try_init_heal_anim(id, mark, exec_func)
	local npc = get_game_object(id)
	end_mark_wounded_state(mark)
	if not npc then return end
	anim_playing 			= true
	cfg.hidden_before_anim 	= mark.hidden
	mark.hidden 			= true
	if exec_func and cfg.sec_enable_heal_anim and not cfg.healing_stalker then
		if zzz_wounded_heal_anim then
			cfg.healing_stalker = npc:id()
			zzz_wounded_heal_anim.use_injector(npc)
		end
		return true
	end
end

function heal_anim_end()
	local id = cfg.healing_stalker
	local npc = get_game_object(id)
	local mark = get_mark(id)
	if not (npc and mark) then return end
	help_wounded_stalker(id, mark, true)
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function help_wounded_stalker(id, mark, skip_anim_check)
	local npc = get_game_object(id)
	if not (npc and mark) then return end
	if (not skip_anim_check) and try_init_heal_anim(id, mark, help_wounded_stalker) then
		vl("[%s] help_wounded_stalker: search anim check, not processing on this call", time_global())
		return true
	end
	mark.hidden 			= cfg.hidden_before_anim
	anim_playing 			= false
	cfg.hidden_before_anim 	= nil
	if not (npc and mark) then return true end
	local medkit    		= cheapest_medical_help_owned()
	local count     		= medkit and actor_aid_item_count(medkit)
	if (not count) or (count < 1) then return true end
	alife_create_item("medkit_script", npc)
	xr_wounded.unlock_medkit(npc)
	game_statistics.increment_npc_statistic(db.actor, "wounded_helped")
end


function hijack_autoloot_keybind()
	if z_auto_looter and cfg.takeall_does_autoloot and cfg.hijack_autoloot_keybind then
		z_auto_looter.config.looter_key = cfg.autoloot_hijack_value
	end
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function can_play_search_anim(mark)
	if not mark then return end
	vl("can_play_search_anim | %s | stalker %s | container %s", nameid(mark.name, mark.id), mark.is_stalker, mark.is_container)
	if not (cfg.fddar_body_search and cfg.search_anim_on_takeall) then return end
	if mark.is_stalker then return true end
	if cfg.fddar_container_search and mark.is_container then return true end
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param exec_func function
function try_init_search_anim(id, mark, exec_func)
	local box = get_game_object(id)
	if box and exec_func and can_play_search_anim(mark) then
		vl("Initializing search animation on %s - %s", mark and mark.name, nameid(box))
		local action_start = fddar_bodysearch.get_template_action_looting_start(box)
		action_start.is_show_ui = true
		lam2.add_action(action_start)
		local action_idle = fddar_bodysearch.get_template_action_looting_idle(box)
		set_loot_window_flag(time_global(), "anim start")
		action_idle.on_execute = (
			function (self, time)
				if npc_loot_claim and npc_loot_claim.actor_looting_claimed then
					self.force_close = true
				end
				if self.force_close or (time > self.ui_open_delay) or lam2.has_queued_actions() then
					if not self.is_input_enabled then
						self.is_input_enabled = true
						if cfg.fddar_disable_walk then level.enable_input() end
					end
					self.force_close = true
					local action_stop = fddar_bodysearch.get_template_action_looting_end()
					lam2.add_action_first(action_stop)
					return lam2.states.success
				end
				return lam2.states.running
			end
		)
		lam2.add_action(action_idle)
		CreateTimeEvent("dotmarks_fddar_takeall", 0, 0.25, (
			function()
				if (not anim_playing) then
					exec_func(id, mark, true)
					clear_loot_window_flag("anim complete")
					return true
				end
			end
		))
		return trueb
	end
end

--- @param id number
function update_mark_after_autoloot(id)
	local mark = get_mark(id)
	if not mark then return end
	mark.autolooted = true
	if mark.alt_interact then
		mark.alt_interact.args.func = take_all_from_box
		mark.alt_interact.args.name = string.format("%s %s", first_upper( gts("st_alti_takeall") ), mark.name)
		mark.alt_interact:Prompt(mark.alt_interact.args.name)
		mark.alt_interact:SetPrompt()
	end
end

--- @param id number
function inspect_artefact(id)
	local obj = get_game_object(id)
	local mark = get_mark(id)
	if (af_inspect and obj and mark) then
		if cfg.play_arty_container_sfx then
			local sfx = mark.arty_container and cfg.container_sfx[mark.arty_container]
			if sfx then
				utils_obj.play_sound(sfx)
			end
		end
		db.actor:hide_detector(true)
		af_inspect.inspect(obj)
	end
	return true
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function try_init_disarm_anim(id, mark, skip_anim_check)
	-- placeholder, no current anim will stand in for it
	-- maybe the two-handed take anim?
	return false
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function remove_bomb(mark)
	if not (mark and mark.id and mark.is_disarmable) then return true end
	vl("Disarming %s and returning a copy of %s", mark.name, mark.inv_section)
	local se_obj 	= alife_create_item(mark.inv_section, db.actor)
	txr_mines._mines[mark.id] = nil
	unregister_scanned_entity(mark.id)
	alife_release_id(mark.id)
	return true 
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function disarm_ied(id, mark, skip_anim_check)
	local obj = get_game_object(id)
	if not (obj and mark and cfg.enable_disarm_ied_act) then return end
	dl("disarm_ied | obj %s | mark %s | en %s", obj:name(), mark, cfg.enable_disarm_ied_act)
	
	if (not skip_anim_check) and try_init_bomb_anim(id, mark, plant_bomb) then
		vl("[%s] disarm_ied: disarm anim check, not deploying on this call", time_global())
		return true
	end
	if mark.func_allow_interact then
		local flags = {ret_value = true}
		func_allow_interact(mark, flags)
		if not flags.ret_value then return true end
	end
	CreateTimeEvent(0, "release_planted_mine", cfg.defuse_obj_delay or 1, remove_bomb, mark)
end


--- @param used_id number
--- @param mode number
--- @param delay number
function replace_invitem_with_bomb(used_id, mode, delay)
	-- Essentially a variation of txr_mines.plant_bomb
	--vl("replace_invitem_with_bomb(%s,%s,%s)", obj and obj:name(), mode, delay)
	local obj = get_game_object(used_id)
	if not (obj and mode) then return end
	
	local now 		= get_time_elapsed()
	local used_sec 	= obj:section()
	local bomb_sec	= txr_mines.EXPLOSIVE_SECTION_LOOKUP[used_sec]
	local pos 		= obj:position()
	local lvid 		= obj:level_vertex_id()
	local gvid 		= obj:game_vertex_id()
	local bomb_obj 	= alife_create(bomb_sec, pos, lvid, gvid)
	local bomb_id 	= bomb_obj.id
	
	_ = txr_mines.FX_BY_SECTION[used_sec] and actor_effects.play_item_fx(txr_mines.FX_BY_SECTION[used_sec])
	
	local witnesses = {}
	for i in pairs(db.OnlineStalkers) do
		local id 	= db.OnlineStalkers[i]
		local npc 	= level.object_by_id(id)
		if npc and IsStalker(npc) and npc:alive() then
			if npc:see(db.actor) then
				-- NPC witnessed player plant bomb
				witnesses[id] = now + math.random(txr_mines.MIN_FORGET_TIME, txr_mines.MAX_FORGET_TIME) * level.get_time_factor()
			end
		end
	end
	txr_mines._mines[bomb_id] = {
		exp_time 	= now + (delay or txr_mines.FUSE_TIME) * level.get_time_factor(),
		mode 		= mode,
		witnesses 	= witnesses,
		active 		= true,
		mine_type 	= obj:section(),
		mine_freq 	= item_radio.get_freq()
	}
		
	CreateTimeEvent(0, "release_planted_mine", 0, txr_mines.release_item, used_id)

	if not cfg.rce_installed then return end
	-- For Remote Controlled Explosives compatibility
	if mode == cfg.mine_modes.MODE_REMOTE and item_radio.get_freq() then
		actor_menu.set_msg(1, gts("st_plant_explosive_remote_freq").. " ".. tostring(item_radio.get_freq()).. " MHz", 4)
		level.map_add_object_spot_ser(
			bomb_id,
			"alife_presentation_squad_monster_1",
			gts("st_plant_explosive_remote_map_marker_pt1") .. " ".. txr_mines.EXPLOSIVE_TYPE[obj:section()].. ", ".. gts("st_plant_explosive_remote_map_marker").. " ".. tostring(item_radio.get_freq()).. " MHz"
		)
	end
	if mode == cfg.mine_modes.MODE_PROX then
		level.map_add_object_spot_ser(
			bomb_id,
			"alife_presentation_squad_monster_1",
			gts("st_plant_explosive_proximity_map_marker") .. " ".. txr_mines.EXPLOSIVE_TYPE[obj:section()]
		)
	end
	if mode == cfg.mine_modes.MODE_TIMER then
		level.map_add_object_spot_ser(
			bomb_id,
			"alife_presentation_squad_monster_1",
			gts("st_plant_explosive_timed_map_marker") .. " ".. txr_mines.EXPLOSIVE_TYPE[obj:section()]
		)
	end
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function try_init_bomb_anim(id, mark, skip_anim_check)
	-- placeholder, no current anim will stand in for it
	-- maybe the take anim? one or two handed?
	return false
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function plant_bomb(id, mark, skip_anim_check)
	local ied = get_game_object(id)
	if (cfg.mine_mode < 0) or not ied then return end
	if (not skip_anim_check) and try_init_bomb_anim(id, mark, plant_bomb) then
		vl("[%s] plant_bomb: bomb anim check, not deploying on this call", time_global())
		return true
	end
	cfg.bomb_timer 	= cfg.bomb_timer or 30
	local timer 	= (cfg.mine_mode ~= 0) and cfg.bomb_timer or nil
	vl("[%s] plant_bomb: mode %s | timer %s", time_global(), cfg.mine_mode, cfg.bomb_timer)
	replace_invitem_with_bomb(id, cfg.mine_mode, timer)
	return true
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function trigger_autoloot(id, mark, skip_anim_check)
	local box = get_game_object(id)
	if not box then return true end
	vl("[%s] trigger_autoloot | %s | skip_anim_check %s", time_global(), nameid(box), not not skip_anim_check)
	if not (zz_autoloot_dotmarks and z_auto_looter and z_auto_looter.auto_looter) then return true end
	if is_body_claimed(id) then return true end
	if (not skip_anim_check) and try_init_search_anim(id, mark, trigger_autoloot) then
		vl("[%s] trigger_autoloot: search anim check, not processing inv on this call", time_global())
		return true
	end

	dl("[%s] Calling Auto Looter for %s", time_global(), nameid(box))
	zz_autoloot_dotmarks.override_id = id
	hijack_autoloot_keybind()
	z_auto_looter.auto_looter(z_auto_looter.config.looter_key)
	return true
end

--- @param id number
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
--- @param skip_anim_check boolean
function take_all_from_box(id, mark, skip_anim_check)
	local box = id and get_game_object(id)
	vl("take_all_from_box | %s | skip_anim_check %s", nameid(box), not not skip_anim_check)
	if not box then return end
	if (not skip_anim_check) and try_init_search_anim(id, mark, take_all_from_box) then
		return true
	end
	if is_body_claimed(id) then return true end

	local function itr_inv(temp, item)
		box:transfer_item(item, db.actor)
		SendScriptCallback("actor_on_item_take_from_box", box, item)
	end
	iterate_any_inventory(box, itr_inv)
	if cfg.markers[id] then
		cfg.markers[id].has_items = false
	end
	utils_obj.play_sound("interface\\items\\inv_items_take_all")
	return true
end

--- @param id number
function pick_up_backpack(id)
	local obj = get_game_object(id)
	if not obj then return end

	local data = {
		stash_id 	= id,
		cancel 		= false,
	}
	SendScriptCallback("actor_on_stash_remove", data)
	if data.cancel then
		return
	end

	if not obj:is_inv_box_empty() then
		take_all_from_box(id)
	end
	
	local mark 	= cfg.markers[id]
	local func 	= (mark and mark.func_pickup) and (
		-- Adding func_pickup to a mark will cause that functor to be used to
		-- perform the actual item pickup process
		function(...)
			-- Wrapper to ensure that custom functors for timeevent return true
			if mark and mark.func_pickup then
				mark.func_pickup(...)
			end
			return true
		end
	) or (
		function(...)
			fake_take_anim(mark, remove_placed_backpack)
			return true
		end
	)

	CreateTimeEvent("bp_take_all", 0, 0.05, func, id)
end

--- @param id number
function eject_mag_from_ground(id)
	-- Largely adapted from the similar eject function in Mags Redux
	if not mags_installed then return end
	local wpn = id and get_game_object(id)
	if not wpn then return end
	if wpn:weapon_in_grenade_mode() or not magazine_binder.is_supported_weapon(wpn) then return end

	magazine_binder.validate_wep(id)
	
	local mag_data = magazine_binder.get_mag_loaded(id)
	
	if mag_data then
		wpn:force_unload_magazine(false)
		wpn:unload_magazine()
		if magazines.retain_round(wpn) and #mag_data.loaded > 0 then
			vl("retaining round of type %s in chamber", stack.peek(mag_data.loaded))
			stack.pop(mag_data.loaded)
			wpn:set_ammo_elapsed(1)
		else
			wpn:set_ammo_elapsed(0)
		end
		
		se_mag = alife_create_item(mag_data.section, db.actor)
		if se_mag then
			magazines.create_time_event("mag_redux", "timer_eject_"..id, 0, magazines.timer_eject_magazine, id, se_mag.id, mag_data)
		else
			dl("Could not create magazine %s", mag_data.section)
		end
		magazine_binder.set_data(id, {
			section     = "no_mag",
			loaded      = {},
			is_weapon   = true,
		})
		magazine_binder.dump_data(mag_data)
		return se_mag.id
	end
end

--- @param id number
function unload_and_take_ammo(id)
	local wpn = id and get_game_object(id)
	if not (wpn and IsWeapon(wpn)) then return end
	local count = wpn:get_ammo_in_magazine()
	if count < 1 then return end
	local atype = wpn:get_ammo_type() + 1
	local ammos = parse_list(ini_sys, wpn:section(), "ammo_class")
	local sec   = ammos and atype and ammos[atype]
	
	if mags_installed then
		vl("Ejecting magazine with %s rounds of %s from %s and giving the mag to actor", count, sec, wpn:name())
		eject_mag_from_ground(id)
	else
		vl("Unloading %s rounds of %s from %s and giving the ammo to actor", count, sec, wpn:name())
		alife_create_item(sec, db.actor, {ammo = count})
		wpn:unload_magazine()
	end

	local mark = cfg.markers[id]
	if not mark then return end
	mark.ammo_count = 0
end

--- @param id number
function unpack_batteries(id)
	-- like in item_device.func_battery, except without the parent check
	local obj 	= id and get_game_object(id)
	if not obj then return end
	local sec   = obj:section()
	local con   = obj:condition()
	local batt  = item_device.device_battery
	local id    = obj:id()
	local dead  = 0.0001
	if ini_sys:section_exist(batt) then
		-- Create new battery for actor and process old one
		alife_create_item(batt, db.actor, {cond = con})
		alife_process_item(sec, id, {cond = dead})
		actor_effects.play_item_fx(batt)
		utils_obj.play_sound("interface\\inv_batt")
	end
	local mark = get_mark(id)
	if not (mark and mark.use_pri) then return end
	mark.condition = dead
	mark.use_pri:SetConditionText(sec, dead)
	mark.use_pri:SetPrompt()
end

function prompt_blocked_by_anim()
	if (not anim_playing) then
		return false
	end
	return not cfg.show_prompt_during_anim
end

--- @param id number
--- @param manual_use boolean
function do_consume_action(id, manual_use)
	local obj = id and get_game_object(id)
	if not obj then return true end
	if (anims_enabled and not manual_use) then
		local _ = debug_dump and vl("[%s] handing consume action off %s to FDDA for animation, it will handle the object from here", time_global(), nameid(obj, id))
		SendScriptCallback("actor_on_item_before_use", obj, {ret_value = true})
	else
		local _ = debug_dump and vl("[%s] causing actor to consume/use %s", time_global(), nameid(obj, id))
		db.actor:eat(obj)
	end
	return true
end

--- @param args table
function delay_action_for_anim(args)
	args = args or {}
	local id        = args.id
	local manual_use= args.manual
	local functor   = args.func
	vl("[%s] delay_action_for_anim start: id %s | manual %s | functor passed: %s", time_global(), id, manual, not not functor)
	if not (id and functor and (type(functor) == "function")) then return true end
	if not cfg.pending_actions[id] then
		-- Pending action record cleared, abort action
		return true
	end

	local timed_out = false
	if time_global() > cfg.pending_actions[id] then
		cfg.pending_actions[id] = nil
		timed_out = true
		-- Pending action timed out, execute action
	end
	
	if fdda_callback and anim_playing and not timed_out then
		return
	end
	if not functor then return true end
	functor(id, manual_use)
	return true
end

--- @param id number
--- @param skip_anim boolean
function force_actor_to_take(id, skip_anim)
	local obj = id and get_game_object(id)
	if not obj then return end
	vl("Forcing actor to take %s via active pickup callback%s", obj and obj:name(), skip_anim and ", skipping animation" or "")
	local send_pickup_callback = fdda_callback or item_pickup_intercept
	local flags = {force = true, ret_value = true, skip_anim = skip_anim}
	send_pickup_callback(obj, flags)
end

--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function pick_up_marked_item(mark)
	if not mark then return end
	vl("Picking up marked item: %s%s", nameid(mark.name, mark.id), mark.physics_obj and " (physobj)" or "")
	if mark.is_glowstick and zz_glowstick_mcm then
		take_glowstick(mark.id)
	elseif mark.physics_obj then
		if mark.func_pickup then
			dump("Executing func_pickup for marker %s", mark.name)
			mark.func_pickup(id)
		end
	else
		force_actor_to_take(mark.id, true)
	end
end

--- @param id number
function take_and_use(id)
	local obj = get_game_object(id)
	if not (obj and db.actor) then return end
	force_actor_to_take(id)
	cfg.pending_actions[id] = time_global() + (cfg.item_use_timeout or 0)
	local manual_use = is_item_manual_use(obj)
	local args = {
		id = id,
		manual = manual_use,
		func = do_consume_action,
	}
	CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_action_for_anim, args)
end

--- @param obj game_object
--- @param mark utils_catspaw_hudmarks.UIHUDMarker
function is_item_manual_use(obj, mark)
	local id    = obj and obj:id()
	local mark  = mark or get_mark(id) or {}
	local sec   = mark.section or (obj and obj:section())
	return mark.manual_use or cfg.manual_use[sec]
end

--- @param id number
function delay_read_action(id)
	vl("delay_read_action | %s | fdda %s | anim_playing %s", id, not not fdda_callback, anim_playing)
	if fdda_callback and anim_playing then return end
	local obj = id and get_game_object(id)
	item_recipe.func_recipe(obj)
	return true
end

--- @param id number
function take_and_inspect(id)
	if id then
		force_actor_to_take(id)
		CreateTimeEvent("dm_delay_inspect", time_global(), cfg.item_use_delay, inspect_artefact, id)
	end
	return true
end

--- @param id number
function take_and_read(id)
	if id then
		force_actor_to_take(id)
		CreateTimeEvent("dm_delay_read", time_global(), cfg.item_use_delay, delay_read_action, id)
	end
	return true
end

--- @param id number
function handle_secondary_interact(id)
	vl("[%s][handle_secondary_interact] Default sec_interact handler for %s", time_global(), id)
	if prompt_blocked_by_anim() then
		local _ = debug_dump and vl("Actor tried to interact but is busy with another item animation")
	return end

	-- Get target object and do validation checks
	local obj = id and get_game_object(id)
	if not obj then return end
	local mark = cfg.markers[id]
	if not is_in_range(id, nil, mark) then return end
	local prompt = mark and mark.alt_interact
	if cfg.prompt_busy_during_anim and prompt and prompt.busystate then return end

	-- Passed validation - identify handler, if any
	if IsWeapon(obj) then
		unload_and_take_ammo(id)
	elseif (IsItem("eatable", obj:section())) then
		take_and_use(id)
	elseif mark.hf_workshop then
		-- Do nothing, it opens its own menu
	else
		take_and_use(id)
	end
end

function on_item_use_anim_start()
	anim_playing = true
end

function on_item_use_anim_stop()
	anim_playing = false
end

--- @param dir number
function cycle_targeted_pickup(dir)
	vl("cycle_targeted_pickup: %s | locked %s | target %s", dir and (dir > 0) and "next" or "previous", locked_id, targeted_id)
	if not (dir and get_current_target()) then return end
	local max       = size_table(nearby_pickups)
	local _ = debug_dump and vl("max %s | in_pickup_range %s", max, size_table(cfg.in_pickup_range))
	if (max < 2) or is_empty(cfg.in_pickup_range) then return end
	local id_curr   = get_current_target()
	local ind_curr  = pickup_index[id_curr] or 1
	local ind_new
	if (dir > 0) then
		ind_new     = (ind_curr < max) and (ind_curr + 1) or 1
	else
		ind_new     = (ind_curr > 1) and (ind_curr - 1) or max
	end
	locked_id       = nearby_pickups[ind_new]
	local _         = ind_new and (ind_new ~= ind_curr) and play_snd_path(cfg.snd_path_blip)
	vl("Pickup cycled | prev ind %s id %s | new ind %s id %s", ind_curr, nearby_pickups[ind_curr], ind_new, locked_id)
end

function reset_nearby_item_tables()
	actor_moved     = true
	locked_id       = nil
	cfg.last_pickup = nil
	nearby_pickups  = {}
	pickup_index    = {}
end

function update_actor_move_state()
	if not db.actor then return end
	actor_moving = (level.actor_moving_state() > 0)
	if actor_moving then
		if not cfg.last_actor_pos then
			cfg.last_actor_pos = db.actor:position()
		end
		local dist = db.actor:position():distance_to(cfg.last_actor_pos)
		actor_moving = dist > (cfg.actor_move_threshold or 0.1)
	end
	return actor_moving
end

function update_nearby_pickups()
	tracelog("start", "update_nearby_pickups")
	if update_actor_move_state() then
		reset_nearby_item_tables()
		return true
	end

	if is_empty(cfg.in_pickup_range) then
		tracelog("end", "update_nearby_pickups")
	return end
	cfg.last_pickup = cfg.available_pickup
	if not is_empty(nearby_pickups) then
		tracelog("end", "update_nearby_pickups")
	return end
	-- pickup tables haven't been updated since actor stopped moving

	local i = 1
	for k,v in spairs(cfg.in_pickup_range) do
		if mark_is_shown(k) then
			nearby_pickups[i] = k
			pickup_index[k] = i
			i = i + 1
		end
	end
	actor_moved = false
	tracelog("end", "update_nearby_pickups")
end

--- @param tutorial string
function setup_tutorial_prompt(tutorial)
	dl("Need to set up a new interact UI for tutorial %s", tutorial)
	local args = get_class_marker_args("Tutorials") or {}
	args.tutorial           = tutorial
	args.fixed              = (not args.is_campfire)
	args.anchor             = maingameui
	args.active_prompt      = trimmed_prompt(gts(cfg.tutorial_hints[tutorial]))
	args.logged_type        = "tutorial prompt"
	cfg.markers[tutorial]   = setup_pri_interact_prompt(maingameui, args)
end

function dump_monitor_states()
	for k,v in pairs(cfg.monitors) do
		dump("State monitor for %s: %s", k, state_monitor(k))
	end
end

function check_tutorial_states()
	tracelog("start", "check_tutorial_states")
	if cfg.tutorial_hints and is_not_empty(cfg.tutorial_hints) then
		if game.has_active_tutorial() then
			cfg.tutorials_cleared = false
		elseif (not cfg.tutorials_cleared) then
			for k,v in pairs(cfg.tutorial_hints) do
				if cfg.markers[k] then
					destroy_prompt(k, "destroying orphaned tutorial prompt")
				end
			end
			cfg.tutorials_cleared = true
		end
	end
	tracelog("end", "check_tutorial_states")
end

--- @param tutorial string
--- @param text string
--- @param flags table
function start_tutorial_prompt(tutorial, text, flags)
	vl("Tutorial start callback for %s: %s", tutorial, text)
	cfg.monitors[tutorial] = state_monitor(tutorial)
	if cfg.monitors[tutorial] then
		flags.ret_value = not cfg.hide_van_interact_ui
		cfg.tutorials_cleared = false
		if cfg.markers[tutorial] then
			cfg.markers[tutorial]:ShowPrompt(true)
		else
			setup_tutorial_prompt(tutorial)
		end
	end
end

--- @param tutorial string
--- @param text string
--- @param flags table
function stop_tutorial_prompt(tutorial, text, flags)
	vl("Tutorial stop callback for %s, shutting down prompt", tutorial)
	cfg.monitors[tutorial] = false
	if cfg.markers[tutorial] then
		destroy_prompt(tutorial, "ending inactive tutorial via callback")
	end 
end

function update_skill_bonus_range()
	if not (haru_skills and haru_skills.skills_levels) then return end
	local skill = cfg.haru_skill_name and haru_skills.skills_levels[cfg.haru_skill_name]
	local sklev = skill and skill.current_level or 0
	cfg.skill_bonus_range = sklev * (cfg.haru_skill_coef or 0)
	update_mark_radii()
	return cfg.skill_bonus_range
end

function do_garbage_collection()
	tracelog("start", "do_garbage_collection")
	local now = time_global()
	if cfg.pending_actions and not is_empty(cfg.pending_actions) then
		for k,v in pairs(cfg.pending_actions) do
			if now > (tonumber(v) or 0) then
				cfg.pending_actions[k] = nil
			end
		end
	end
	if cfg.block_loot_window then
		if (now - cfg.block_loot_window) > 3000 then
			vl("cfg.block_loot_window has been set for longer than 3 seconds, clearing")
			clear_loot_window_flag("timeout")
		end
	end
	tracelog("end", "do_garbage_collection")
end

function update_hint_filters()
	tracelog("start", "update_hint_filters")
	if (not (cfg.hint_filter and cfg.hint_filter.enabled)) then return end
	local hint = cfg.hint_filter.last_raw_text
	if is_empty(cfg.hint_filter.enabled) then return end
	local text = cfg.hint_filter.update_text()
	if not text then return end
	dump("[%s] Hint filter update%s", time_global(), text and (" - text is: "..text) or ", no text")
	tracelog("end", "update_hint_filters")
end

function update_mark_vis_ignores()
	for id,mark in pairs(cfg.markers) do
		if (mark.is_stalker and mark.is_alive) then
			mark.vis_ignore_mute	= vis_ignore_mute(id)
		end
	end
end

local function perform_debugging_checks()
	if not hmm then return end
	dump("[Targets] Lookat curr: %s last %s | Pickup curr: %s last %s | Xhair curr: %s last %s", hmm.curr_target, hmm.last_target, hmm.curr_pickup, hmm.last_pickup, hmm.curr_crosshair, hmm.last_crosshair)
end


-- =======================================================================
--      MAIN SCAN LOOP
-- =======================================================================
function actor_on_update()
	if cfg.debug_trace then
		printf("")
		loop_num = (loop_num or 0) + 1
		tracelog("start", "actor_on_update", "loop "..tostring(loop_num))
	end
	perform_debugging_checks() -- only uncommented when needed
	if not scanning then return end
	do_garbage_collection()
	update_hint_filters()
	cfg.actor_comm  = character_community(db.actor):sub(7)
	cfg.active_task_target_id = get_task_target()
	-- ===================================================================
	--  Tutorial monitors
	--  Watches for state flags set by modxml_tutorial_hooks.script
	--  Mostly cleanup now that tutorials are handled via callbacks
	-- ===================================================================
	if cfg.tut_check_interval then
		if (next_tut_check <= time_global()) then
			next_tut_check = get_next_tg_interval(cfg.tut_check_interval)
			dotmarks_main.in_sleep_zone = is_actor_in_sleep_zone()
			check_tutorial_states()
		end
	end
	-- ===================================================================
	--  Update nearby pickup items and identifies current/locked target
	--  Accuracy is critical, should happen as often as possible
	-- ===================================================================    
	update_nearby_pickups()
	if locked_id then
		local _ = debug_dump and vl("locked_id is %s, skipping target updates and scans", locked_id)
		tracelog("end", "actor_on_update", "loop "..tostring(loop_num))
		return
	end
	update_targeted_object()
	-- ===================================================================
	--  Near scan - iterate objects within near_scan_radius
	--  This quickly picks up newly-spawned or dropped objects
	--  Frequent
	-- ===================================================================
	if cfg.near_scan_interval then
		if (next_near_scan <= time_global()) then
			tracelog("start", "scan_nearby_entities", "near")
			next_near_scan   = get_next_tg_interval(cfg.near_scan_interval)
			scan_nearby_entities(near_scan_radius())
		end
	end
	-- ===================================================================
	--  Early scan - iterate within near_scan_radius + early_scan_radius
	--  Instantiates markers for objects before they would become visible
	--  Less frequent
	-- ===================================================================
	if cfg.early_scan_interval then
		update_mark_vis_ignores()
		if (next_early_scan <= time_global()) then
			tracelog("start", "scan_nearby_entities", "early")
			next_early_scan   = get_next_tg_interval(cfg.early_scan_interval)
			scan_nearby_entities(early_scan_radius())
		end
	end
	tracelog("end", "actor_on_update", "loop "..tostring(loop_num))
end

-- =======================================================================

function targeted_deployable_bomb()
	local id = get_current_target()
	local mark = get_mark(id)
	return mark and mark.placeable_mine and id or nil
end


function is_obj_crosshair_target(id) return hmm and hmm.current_crosshair and (id == hmm.current_crosshair) end
function is_obj_pickup_target(id) return hmm and hmm.current_pickup and (id == hmm.current_pickup) end
function is_obj_current_target(id) return hmm and hmm.current_target and (id == hmm.current_target) end

function pressing_any_mod_key()
	return (ui_mcm.MOD_SHIFT and not cfg.ignored_modkeys[1])
		or (ui_mcm.MOD_CTRL and not cfg.ignored_modkeys[2])
		or (ui_mcm.MOD_ALT and not cfg.ignored_modkeys[3])
end

--- @param key number
function recent_long_press(key)
	key = key or use_dik
	--local key_match = cfg.last_hold and (cfg.last_hold.key == key)
	--local timeout = key_match and not timeout
	--dump("key %s | tg %s | cfg.last_hold %s | delay %s | timed out %s | res %s", use_dik, time_global(), cfg.last_hold, cfg.long_press_delay, timeout)
	return cfg.last_hold and (cfg.last_hold.key == key) and not timed_out(cfg.last_hold.time, cfg.long_press_delay or 50)
end

function recent_double_tap()
	if not cfg.last_tap then return end
	if (time_global() - cfg.last_tap) < cfg.long_press_delay then return true end
	cfg.last_tap = nil
end

--- @param key number
function is_modkey_ignored(key)
	key = (key and tonumber(key))
	if not key then 
		return cfg.ignored_modkeys[1]
			or cfg.ignored_modkeys[2]
			or cfg.ignored_modkeys[3]
	end
	return cfg.ignored_modkeys[key]
end


--- @param key number
--- @param bind number
--- @param dis boolean
--- @param flags table
function on_before_key_press(key, bind, dis, flags)
	--dump("on_before_key_press(%s, %s, %s, ret: %s)", key, bind, dis, flags and flags.ret_value)
	if input_killswitch() then return end
	if (key == use_dik) and cfg.watch_use then
		cfg.use_released = nil
		cfg.held_key = key
		set_loot_window_flag(time_global(), "key press")
		local id = get_current_target()
		local mark = get_mark(id) or {}
		local mkey = 
		vl("[%s][on_before_key_press] Beginning press of interact key %s | Current targets:\n" ..
			"[ mark: %s (%s) | crosshair: %s | pickup: %s | engine: %s ]",
			time_global(), key,
			mark.name, mark.id, hmm and hmm.current_crosshair, hmm and hmm.current_pickup, hmm and hmm.current_target)
		if pressing_any_mod_key() or not (mark.is_stalker and mark.is_wounded) then return end
		flags.ret_value = false
	end
end

--- @param id number
function trigger_fddar_scavenger_effect(id)
	if not (haru_skills and not cfg.fddar_body_search) then return end
	vl("FDDAR body search is disabled, triggering Scavenger skill gain manually to fix FDDAR bug")
	CreateTimeEvent("fddar_manual_scav", 0, 0.15, (
		function()
			local npc = get_game_object(id)
			if not npc then return true end
			fddar_bodysearch.is_haruka_scav_skill_add = true
			fddar_bodysearch.haruka_scav_skill_npc = npc
			fddar_bodysearch.haruka_scavanger_effect()
			return true
		end			
	))
end

--- @param id number
function do_use_release_action_manually(id)
	if pressing_any_mod_key() or recent_double_tap() then return end
	local obj = get_game_object(id)
	local mark = get_mark(id)
	-- Target exists, no completed hold action
	local flags = {ret_value = true}
	dump("Sending callback dotmarks_on_manual_interact_release | %s | %s | %s", id, nameid(mark and mark.name, id), flags and flags.ret_value)
	SendScriptCallback("dotmarks_on_manual_interact_release", id, mark, flags)
	if not (flags and flags.ret_value) then
		dump("Further handling aborted by callback")
		return
	end

	if is_target_pickup(id) and ((id == locked_id) or not locked_id) then
		cfg.use_released = nil
		dump("[%s] No completed hold action, item pickup should occur", time_global())
		if mark and mark.physics_obj then
			fake_take_anim(mark)
		else
			force_actor_to_take(id)
		end
	elseif is_target_container(id, obj:clsid()) then
		dl("[%s] No completed hold action, target is a container", time_global())

		if mark and mark.is_stalker then		
			if is_body_claimed(id) then
				if cfg.grok_claim then
					vl("Calling Grok loot claim")
					local dik = bind_to_dik(key_bindings.kUSE)
					local flags = {ret_value = true}
					grok_loot_claim.on_before_key_press(dik, key_bindings.kUSE, nil, flags)
					if not flags.ret_value then return end
				else
					vl("Calling NPC loot claim")
					npc_loot_claim.actor_looting(obj)
					if npc_loot_claim.actor_looting_claimed then return end
					vl("Loot claim passed, looting")
				end
			end
			if cfg.fddar_fix_scav_bug then
				trigger_fddar_scavenger_effect(id)
			end
		end
		if z_ui_inventory_dotmarks then
			dl("[%s] No completed hold action, allow inventory interaction with %s", time_global(), obj:name())
			cfg.use_released = nil
			use_obj_by_id(id)
		else
			alert("ERROR! z_ui_inventory_dotmarks could not be found, please reinstall DotMarks")
		end
	elseif mark and mark.is_stalker and mark.is_wounded then
		dl("Forcing actor to talk with wounded NPC")
		cfg.use_released = nil
		xr_effects.force_talk(db.actor, obj, {true})
	else
		vl("No manual action found for %s, assume engine will handle it", nameid(obj, id))
	end
end

--- @param key number
function on_key_release(key)
	if input_killswitch() then return end
	clear_loot_window_flag((key == use_dik) and "released use key")
	if key == cfg.held_mod then cfg.held_mod = nil end
	if (key == use_dik) then
		if (key == cfg.held_key) then
			cfg.held_key = nil
			cfg.use_released = cfg.use_released or time_global()
			local id = get_current_target()
			if not id then return end
			local dur = cfg.holding and cfg.holding.peak_hold
			local time = cfg.holding and cfg.holding.hold_time
			local can_trigger_action = not (dur and time and (dur >= time))
			local action_text = (debuglogs or debug_dump) and can_trigger_action and ", checking for action" or ", no action to trigger"
			dump("[%s] use key released%s | set at %s | dur held %s | hold time %s", time_global(), action_text, cfg.use_released, dur, time)
			if can_trigger_action then
				do_use_release_action_manually(id)
			end
		end
	end
end

--- @param obj game_object
function actor_on_update_pickup(obj)
	cfg.update_pickup_firing = true
	cfg.last_pickup = cfg.available_pickup
	cfg.available_pickup = obj and obj:id() or nil

	if cfg.last_pickup and cfg.available_pickup and (cfg.last_pickup ~= cfg.available_pickup) then
		reset_nearby_item_tables()
	end
end

--- @param obj game_object
function actor_on_item_take(obj)
	local id = obj and obj:id()
	if get_mark(id) then
		dump("Actor just took %s, unregistering scanned object", nameid(obj, id))
		unregister_scanned_entity(id)
	end
end

--- @param box game_object
--- @param item game_object
function remove_obj_from_box_table(box, item)
	if not (box and item) then return end
	local b_id = box:id()
	if not b_id then return end
	if not cfg.invboxes[b_id] then return end
	if not cfg.invboxes[b_id].items then
		cfg.invboxes[b_id].items = {}
	end
	local i_id = item:id()
	if not i_id then return end
	cfg.invboxes[b_id].items[i_id] = nil
	cfg.invboxes[b_id].searched = true

	local mark      = cfg.markers[b_id] or {}
	local was_items = mark.has_items
	local num_items = size_table(cfg.invboxes[b_id].items)
	mark.has_items  = num_items > 0
	vl("remove_obj_from_box_table completed for %s <- %s", item:name(), box:name())
end

--- @param box game_object
--- @param item game_object
function add_obj_to_box_table(box, item)
	if not (box and item) then return end
	local b_id = box:id()
	if not b_id then return end
	if not cfg.invboxes[b_id] then
		init_new_inventory_box(b_id)
	end
	if not cfg.invboxes[b_id].items then
		cfg.invboxes[b_id].items = {}
	end
	local i_id      = item:id()
	local sec       = item:section()
	if not i_id then return end
	cfg.invboxes[b_id].items[i_id] = sec

	local mark      = cfg.markers[b_id] or {}
	mark.has_items  = true
	cfg.invboxes[b_id].owned = true
	vl("add_obj_to_box_table completed for %s -> %s", item:name(), box:name())
end

--- @param box game_object
--- @param item game_object
--- @param mode string
--- @param bag_from string
function ActorMenu_on_item_after_move(box_id, item, mode, bag_from)
	vl("ActorMenu_on_item_after_move: box %s | item %s | bag_from %s", box_id, nameid(item), bag_from)
	if (mode == 2) or (mode == "loot") then
		local box = box_id and get_game_object(box_id)
		if (bag_from == 7) or (bag_from == "npc_bag") then
			remove_obj_from_box_table(box, item)
		else
			add_obj_to_box_table(box, item)
		end
	end
end

--- @param victim game_object
--- @param killer game_object
--- @param source game_object
function handle_npc_death(victim, killer, source)
	local id = victim and victim:id()
	if not id then return end
	local unk = "unknown"
	if source then
 		source = string.format("(%s | killed by: %s)", source, killer and killer:name() or unk)
	end
	vl("[%s] %s has died%s, unregistering them and re-registering as corpse object", time_global(), victim:name(), source or unk)
	unregister_scanned_entity(id)
	scan_nearby_object(nil, id)
end

function npc_on_death_callback(victim, killer) 			handle_npc_death(victim, killer, "npc_on_death_callback") end
function monster_on_death_callback(victim, killer) 		handle_npc_death(victim, killer, "monster_on_death_callback") end 
function npc_on_silent_kill_callback(victim, killer) 	handle_npc_death(victim, killer, "npc_on_silent_kill_callback") end

function ignore_mouse_wheel()
	return (
		cfg.ignore_mouse_wheel or
		axr_main.scoped_weapon_is_zoomed or
		axr_main.binoc_is_zoomed or
		actor_menu.inventory_opened() or
		item_device.is_pda_active() or
		(ui_workshop.GUI and ui_workshop.GUI:IsShown())
	)
end

--- @param scroll_dir number
--- @param flags table
function on_mouse_wheel(scroll_dir, flags)
	local id = get_current_target()
	if (not cfg.wheel_cycles_pickups) then return end
	if (not id) or ignore_mouse_wheel() then return end
	local direction         = (scroll_dir > 0) and 1 or -1
	local _ = debug_dump and vl("on_mouse_wheel: %s | direction: %s", scroll_dir, direction)
	cycle_targeted_pickup(direction)
	flags.ret_value         = false
end

--- @param color_key string
--- @param csv_string string
function parse_color_data(color_key, csv_string)
	if not (color_key and csv_string) then return end
	local c         = csv_argb_to_tbl(csv_string)
	cfg.colors[color_key]   = c
	local str       = string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
	set_color_token(color_key, str)
	return c
end

function parse_file_data()
	local ini_cfg = ini_file_ex(dotmarks_config_file)
	for k,_ in pairs(cfg.reset_table) do
		local ver = tonumber(k)
		local res = "reset_" .. tostring(k)
		cfg.version_resets[ver] = ini_cfg:collect_section(res)
	end
	cfg.mine_mode = clamp(tonumber(cfg.sec_mode_setupthebomb) or 0, -1, 2)
	cfg.rce_installed = not not txr_mines.func_remote_plant
	for k,v in pairs (txr_mines.EXPLOSIVE_SECTION_LOOKUP) do
		cfg.disarmables[v] = k
	end
	if cfg.colors then
		for k,v in pairs(cfg.colors) do
			if k:find("clr_") then
				parse_color_data(k, v)
			else
				cfg.colors[k]   = nil
			end
		end
	end
	cfg.weight_colors = {
		[0] = "clr_weight_ok",
		[1] = "clr_weight_high",
		[2] = "clr_weight_over"
	}
	cfg.color_icon_itemcard     = clr_tbl(cfg.color_icon_itemcard)
	cfg.unsquish_ratio          = utils_catspaw_hudmarks.update_unsquish_ratio() or 1
	cfg.unsquish                = (function(w) return (w or 0) * (cfg.unsquish_ratio or 1) end)
	local ini_mutant            = ini_file("items\\settings\\mutant_loot.ltx")
	cfg.mutant_decay_time       = ini_mutant:r_float_ex("mutant_loot_mod","decay_time") or 7200
	local factions      = game_relations.factions_table
	local ini_fac       = ini_file_ex("plugins\\faction_profile.ltx")
	cfg.notable_npcs    = {}
	cfg.vendors         = cfg.vendors or {}
	for _,fac in pairs(factions) do
		local fd = ini_fac:collect_section(fac)
		cfg.notable_npcs[fac] = {
			leader      = fd.leader,
			trader      = fd.trader,
			mechanic    = fd.mechanic,
			medic       = fd.medic,
			barman      = fd.barman,
			guide       = fd.guide
		}
		if fd.leader then   cfg.vendors[fd.leader]    = "leader" end
		if fd.trader then   cfg.vendors[fd.trader]    = "trader" end
		if fd.mechanic then cfg.vendors[fd.mechanic]  = "mechanic" end
		if fd.medic then    cfg.vendors[fd.medic]     = "medic" end
		if fd.barman then   cfg.vendors[fd.barman]    = "barman" end
		if fd.guide then    cfg.vendors[fd.guide]     = "guide" end
	end
	if debug_dump then
		vl("Loaded NPC vendors:")
		for k,v in pairs(cfg.vendors) do
			vl("|| %s = %s", k,v)
		end
	end
	hintfilters = cfg.hint_filter
	cfg.grok_claim = not not grok_loot_claim
	local save_flag = axr_main.config:r_value("mcm", "dotmarks/dmarkadv/write_to_save", {val=1})
	if save_flag ~= nil then
		cfg.write_to_save = save_flag
	end
end

--- @param kill boolean
function set_item_pickup_callbacks(kill)
	if kill or killswitch("pickup") then
		UnregisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
	elseif not get_fdda_callback() then
		RegisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
		dl("No form of FDDA installed, registering internal pickup callback")
		cfg.pickup_callback_set = true
	end
end

--- @param kill boolean
function set_item_anim_callbacks(kill)
	if lam2 and fddar_installed then
		if anims_enabled and not (kill or killswitch()) then
			if lam2.Subscribe then
				dl("Subscribing FDDAR item animation callbacks")
				lam2.Subscribe("on_anim_queue_start", on_item_use_anim_start)
				lam2.Subscribe("on_anim_queue_stop", on_item_use_anim_stop)
			else
				RegisterScriptCallback("actor_on_update", fddar_update_current_anim_state)
			end
		else
			if lam2.Unsubscribe then
				dl("Unsubscribing FDDAR item animation callbacks")
				lam2.Unsubscribe("on_anim_queue_start", on_item_use_anim_start)
				lam2.Unsubscribe("on_anim_queue_stop", on_item_use_anim_stop)
			else
				UnregisterScriptCallback("actor_on_update", fddar_update_current_anim_state)
			end
		end
	elseif ea_callbacks and fdda_installed then
		if anims_enabled and not (kill or killswitch()) then
			dl("Registering FDDA item animation callbacks")
			ea_callbacks.EA_RegisterScriptCallback("ea_on_item_use", on_item_use_anim_start)
			ea_callbacks.EA_RegisterScriptCallback("ea_on_item_anim_stop", on_item_use_anim_stop)
		else
			dl("Unregistering FDDA item animation callbacks")
			ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_use", on_item_use_anim_start)
			ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_anim_stop", on_item_use_anim_stop)
		end
	end
end

--- @param kill boolean
function set_handler_callbacks(kill)
	if kill or killswitch() then
		UnregisterScriptCallback("actor_on_update", actor_on_update)
		UnregisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		UnregisterScriptCallback("on_key_release", on_key_release)
		UnregisterScriptCallback("on_before_key_press", on_before_key_press)
		UnregisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		UnregisterScriptCallback("on_tutorial_prompt_start", start_tutorial_prompt)
		UnregisterScriptCallback("on_tutorial_prompt_stop", stop_tutorial_prompt)
		if kill then
			UnregisterScriptCallback("on_option_change", on_option_change)
		end
	else
		RegisterScriptCallback("actor_on_update", actor_on_update)
		RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		RegisterScriptCallback("on_key_release", on_key_release)
		RegisterScriptCallback("on_before_key_press", on_before_key_press)
		RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		RegisterScriptCallback("on_tutorial_prompt_start", start_tutorial_prompt)
		RegisterScriptCallback("on_tutorial_prompt_stop", stop_tutorial_prompt)
	end
	set_item_pickup_callbacks(kill)
	set_item_anim_callbacks(kill)
end

local function log_other_addon_settings()
	if not debug_dump then return end
	vl("Loaded settings from other addons:\n"..
		"fddar/pickup/multipickup -> fddar_multipickup %s\n" ..
		"fddar/pickup/enable -> fddar_pickup_anim %s\n" ..
		"EA_settings/enable_animations -> fdda_anims_enabled: %s\n" ..
		"EA_settings/take_item_anim -> fdda_pickup_anim: %s\n" ..
		--"item_icon_info/part_dots/show_on_wpn -> show_parts_weapons: %s\n" ..
		--"item_icon_info/part_dots/show_on_armor -> show_parts_armor: %s\n" ..
		"item_icon_info/part_dots/wpo_green -> parts_wpo_grn: %s\n" ..
		"item_icon_info/part_dots/wpo_yellow -> parts_wpo_yel: %s\n" ..
		"item_icon_info/part_dots/wpo_orange -> parts_wpo_orn: %s",
		cfg.fddar_multipickup, cfg.fddar_pickup_anim,
		cfg.fdda_anims_enabled, cfg.fdda_pickup_anim,
		--cfg.show_parts_weapons, cfg.show_parts_armor,
		cfg.parts_wpo_grn, cfg.parts_wpo_yel, cfg.parts_wpo_orn
	)
end

function on_option_change()
	local _ = debug_dump and vl("on_option_change() triggered at %s", time_global())
	dl("Iterating through settings and looking for MCM overrides\n" ..
		"+ You may see a burst of MCM warnings about bad paths during this process. These are completely harmless and should be ignored."
	)
	debuglogs   = get_mcm("dotmarks/dmarkadv/debuglogs", debuglogs)
	verbose     = get_mcm("dotmarks/dmarkadv/verbose", verbose)
	local log 	= (debuglogs or debug_dump or verbose or DEV_DEBUG)
	local _ 	= log and printf("Debug logging enabled: %s | verbose %s | debug_dump %s | DEV_DEBUG %s", debuglogs, verbose, debug_dump, DEV_DEBUG)
	local reset	= {}

	if not cfg.first_update then
		cfg.first_update = true
		local last_version = ui_mcm.get("dotmarks/dmarkmain/last_version")
		local last_release = ui_mcm.get("dotmarks/dmarkmain/last_release")
		if not last_release then
			_=log and printf("No previous DotMarks version information found in MCM, setting to current version")
		else
			local vtext = "Found MCM config from DotMarks version %s, rel %s"
			if tonumber(last_release) < release_date then
				vtext = vtext .. ", updating to v"..script_version.." release "..release_date
			end
			_=log and printf(vtext, last_version, last_release)
		end
		
		if cfg.version_resets then
			for rel, opts in pairs(cfg.version_resets) do
				if (not last_release) or (last_release < rel) then
					dump("Existing release %s is older than %s, adding opts to reset table", last_release, rel)
					for k,_ in pairs(opts) do
						dump("Will reset opt %s", k)
						reset[k] = true
						cfg.upgrade_settings_defaulted = true
					end
				end
			end
		end
		ui_mcm.set("dotmarks/dmarkmain/last_version", script_version)
		ui_mcm.set("dotmarks/dmarkmain/last_release", release_date)
	end

	vl("Loading config table")

	for k,v in pairs(cfg) do
		if type(v) ~= "table" then
			local mcm_path = cfg.mcm_paths[k]
			if mcm_path and mcm_path:find("/$") then
				mcm_path = mcm_path .. k
			end
			if mcm_path then
				if reset[k] then
					dl("Defaulting MCM value %s = %s (was %s)", k, v, get_mcm(mcm_path, cfg[k]))
					ui_mcm.set(mcm_path, v)
				else
					local foo = ui_mcm.get(mcm_path)
					cfg[k] = get_mcm(mcm_path, cfg[k])
					vl("Loading MCM value %s = %s", k, cfg[k])
				end
			else
				_ = debug_dump and vl("No MCM path found for %s, skipping", k)
			end
		end
	end
	if zz_autoloot_dotmarks then
		zz_autoloot_dotmarks.hijack_autoloot_keybind = cfg.hijack_autoloot_keybind
		cfg.keybind_hijack_value = zz_autoloot_dotmarks.keybind_hijack_value
	end
	log_other_addon_settings()

	if cfg.argb_dot_normal then
		parse_color_data("clr_dmark_norm", cfg.argb_dot_normal)
	end
	for k,v in pairs(cfg) do
		if k:find("^swap_") and v.load_argb then
			v.custom_argb = csv_argb_to_tbl(cfg[v.load_argb])

			if v.custom_argb then
				for i,j in pairs(v.custom_argb) do
				end
			end
			v.load_argb = nil
		end
	end

	for k,v in pairs(cfg.scan) do
		cfg.scan[k] = get_mcm("dotmarks/dmarkobjs/scan_" .. string.lower(k), cfg.scan[k])
		_ = debug_dump and vl("Scanning %s = %s", k, v)
	end

	if z_fdda_pickup_intercept_dotmarks then
		fddar_installed = (not not z_fdda_pickup_intercept_dotmarks.fddar_oibp)
		fdda_installed  = (not not z_fdda_pickup_intercept_dotmarks.fdda_oibp)
		anims_enabled   = (fddar_installed and cfg.fddar_pickup_anim) or (fdda_installed and cfg.fdda_pickup_anim and cfg.fdda_anims_enabled)
		cfg.fddar_fix_scav_bug = fddar_installed and cfg.fddar_fix_scav_bug
	end

	cfg.pending_actions = {}
	scanned             = {}
	use_dik             = bind_to_dik(key_bindings.kUSE)
	if cfg.bind_sec_interact == nil then
		cfg.bind_sec_interact = use_dik
	end
	cfg.watch_use   = (use_dik == cfg.bind_sec_interact) and not cfg.hide_sec_interact_ui
	if cfg.markers and not is_empty(cfg.markers) then
		for k,v in pairs(cfg.markers) do
			v:Destroy(nil, "reset after on_option_change")
		end
	end
	cfg.ignored_modkeys[1] = not not cfg.simple_press_ignore_shift
	cfg.ignored_modkeys[2] = not not cfg.simple_press_ignore_ctrl
	cfg.ignored_modkeys[3] = not not cfg.simple_press_ignore_alt

	cfg.bind_fmprev = key_bindings.kWPN_FIREMODE_PREV
	cfg.bind_fmnext = key_bindings.kWPN_FIREMODE_NEXT
	reset_nearby_item_tables()
	set_handler_callbacks()
	st_kg           = gts("st_kg")
	cfg.show_part_condition     = cfg.show_parts_weapons or cfg.show_parts_armor
	cfg.double_tap_time 		= get_mcm("mcm/mcm_kb/mcm_kb_main/dtaptime2", 200)
	cfg.sec_enable_arty_anim 	= af_inspect and cfg.sec_enable_arty_anim
	local pickup_names_cmd 		= "g_draw_pickup_item_names " .. (cfg.hide_pickup_item_names and "0" or "1") 
	exec_console_cmd(pickup_names_cmd)
	CreateTimeEvent("autoloot_override", 0, 0.25, hijack_autoloot_keybind)
end

function load_state(data)
	if not cfg.write_to_save then return end
	if not (data and data.dotmarks) then return end
	cfg.invboxes = data.dotmarks.invboxes or cfg.invboxes or {}
end

function save_state(data)
	if cfg.clean_save_data and data and data.dotmarks then
		empty_table(data.dotmarks)
		data.dotmarks = nil
		cfg.clean_save_data = false
		return
	end
	if not cfg.write_to_save then return end
    data.dotmarks = data.dotmarks or {}
    if cfg.invboxes then
    	data.dotmarks.invboxes = {}
    	for k,v in pairs(cfg.invboxes) do
    		if v.found then
    			printf("Storing found stash data for %s", nameid(v.name, id))
    			data.dotmarks.invboxes[k] = v
    		end
    	end
    end
end

function on_game_start()
	valid_mcm_version = dotmarks_mcm and dotmarks_mcm.valid_mcm_version
	local bad_mcm_version = (not valid_mcm_version) or not valid_mcm_version()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	-- This callback is always registered so that we can notify the player of init failure
	if (base_failed == nil) then
		base_failed = not init_base_config(dotmarks_config_file, { logging = debug_dump, called_by = script_name })
	end
	if cfg and (not bad_mcm_version) then
		mags_installed = (magazines and magazine_binder)
		parse_file_data()
		RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
		RegisterScriptCallback("ActorMenu_on_item_after_move", ActorMenu_on_item_after_move)
		RegisterScriptCallback("actor_on_item_take_from_box", remove_obj_from_box_table)
		RegisterScriptCallback("actor_on_item_put_in_box", add_obj_to_box_table)
		RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
		RegisterScriptCallback("on_key_release", on_key_release)
		RegisterScriptCallback("on_before_key_press", on_before_key_press)
		RegisterScriptCallback("on_option_change", on_option_change)
		RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback)
		RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback)
		--RegisterScriptCallback("on_before_level_changing", on_before_level_changing)
		if stealth_kill_detection then
			RegisterScriptCallback("npc_on_silent_kill_callback", npc_on_silent_kill_callback)
		end
		RegisterScriptCallback("load_state", load_state)
		RegisterScriptCallback("save_state", save_state)

		on_option_change()
		if (fdda_installed and fddar_installed) then
			alert("WARNING: Both FDDA and FDDA Redone scripts were found, but FDDA scripts should be disabled! Leaving them both active can lead to busyhands or other serious issues.")
		end
		SendScriptCallback("dotmarks_on_init_complete", script_version, release_date)
		return
	end

	local failmsg = ""
	if base_failed then
		cfg = nil
		failmsg = " to load base config from dotmarks_main"
	elseif bad_mcm_version then
		failmsg = string.format(" to detect MCM 1.7.0 or higher")
	elseif not cfg then
		cfg = nil
		failmsg = string.format(" to load config file %s", dotmarks_config_file)
	end
	alert("[%s] ERROR: Initialization failed%s!\n" ..
		"! DotMarks startup aborted, skipping callback registration", script_name, failmsg)
end

